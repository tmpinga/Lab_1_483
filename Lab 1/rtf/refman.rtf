{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment ECET 483 Lab 1  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}ECET 483 Lab 1}
{\comment Generated byDoxgyen. }
{\creatim \yr2013\mo5\dy1\hr18\min45\sec34}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
License{\tc \v License}\par \pard\plain 
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab The name of Atmel may not be used to endorse or promote products derived from this software without specific prior written permission.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab This software may only be redistributed and used in connection with an Atmel microcontroller product.\par}
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
uxQueueMessagesWaiting{\tc \v uxQueueMessagesWaiting}\par \pard\plain 
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid unsigned portBASE_TYPE {\b uxQueueMessagesWaiting( const xQueueHandle xQueue )};\par}
Return the number of messages stored in a queue.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{A handle to the queue being queried.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The number of messages available in the queue. \par
}}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
vQueueDelete{\tc \v vQueueDelete}\par \pard\plain 
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vQueueDelete( xQueueHandle xQueue )};\par}
Delete a queue - freeing all the memory allocated for storing of items placed on the queue.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{A handle to the queue to be deleted. \cell }
{\row }
}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
xTaskHandle{\tc \v xTaskHandle}\par \pard\plain 
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Type by which tasks are referenced. For example, a call to xTaskCreate returns (via a pointer parameter) an xTaskHandle variable that can then be used as a parameter to vTaskDelete to delete the task. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
taskYIELD{\tc \v taskYIELD}\par \pard\plain 
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Macro for forcing a context switch. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
taskENTER_CRITICAL{\tc \v taskENTER_CRITICAL}\par \pard\plain 
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.\par
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
taskEXIT_CRITICAL{\tc \v taskEXIT_CRITICAL}\par \pard\plain 
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.\par
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
taskDISABLE_INTERRUPTS{\tc \v taskDISABLE_INTERRUPTS}\par \pard\plain 
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Macro to disable all maskable interrupts. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
taskENABLE_INTERRUPTS{\tc \v taskENABLE_INTERRUPTS}\par \pard\plain 
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h\par
Macro to enable microcontroller interrupts. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
xTaskGetTickCount{\tc \v xTaskGetTickCount}\par \pard\plain 
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid portTickType {\b xTaskGetTickCount( void )};\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The count of ticks since vTaskStartScheduler was called.\par
}task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid portTickType {\b xTaskGetTickCountFromISR( void )};\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The count of ticks since vTaskStartScheduler was called.\par
}This is a version of {\b xTaskGetTickCount()} that is safe to be called from an ISR - provided that portTickType is the natural word size of the microcontroller being used or interrupt nesting is either not supported or not being used. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
uxTaskGetNumberOfTasks{\tc \v uxTaskGetNumberOfTasks}\par \pard\plain 
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid unsigned short {\b uxTaskGetNumberOfTasks( void )};\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The number of tasks that the real time kernel is currently managing. This includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. \par
}}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
pcTaskGetTaskName{\tc \v pcTaskGetTaskName}\par \pard\plain 
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery );\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The text (human readable) name of the task referenced by the handle xTaskToQueury. A task can query its own name by either passing in its own handle, or by setting xTaskToQuery to NULL. INCLUDE_pcTaskGetTaskName must be set to 1 in {\b FreeRTOSConfig.h} for {\b pcTaskGetTaskName()} to be available. \par
}}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
vTaskList{\tc \v vTaskList}\par \pard\plain 
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void vTaskList( char *pcWriteBuffer );\par}
configUSE_TRACE_FACILITY must be defined as 1 for this function to be available. See the configuration section for more information.\par
NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.\par
Lists all the current tasks, along with their current state and stack usage high water mark.\par
Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pcWriteBuffer} \cell }{A buffer into which the above mentioned details will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. \cell }
{\row }
}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
vTaskGetRunTimeStats{\tc \v vTaskGetRunTimeStats}\par \pard\plain 
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void vTaskGetRunTimeStats( char *pcWriteBuffer );\par}
configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The application must also then provide definitions for {\b portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()} and portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.\par
NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.\par
Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the {\b portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()} macro. Calling {\b vTaskGetRunTimeStats()} writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pcWriteBuffer} \cell }{A buffer into which the execution times will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. \cell }
{\row }
}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Generic board support\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Global interrupt management\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Deprecated interrupt definitions\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Atmel part identification macros\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AVR UC3 parts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AVR XMEGA parts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
megaAVR parts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
tinyAVR parts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SAM parts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Assembler Support\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Program memory\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xQueueCreate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xQueueSend\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xQueueReceive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xQueueSendFromISR\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xQueueReceiveFromISR\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xTaskCreate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xTaskCreateRestricted\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskDelete\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskDelay\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskDelayUntil\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
uxTaskPriorityGet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskPrioritySet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskSuspend\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskResume\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskResumeFromISR\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskStartScheduler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskEndScheduler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
vTaskSuspendAll\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
xTaskResumeAll\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b A_BLOCK_LINK} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QueueDefinition} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tskTaskControlBlock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xLIST} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xLIST_ITEM} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xMEMORY_REGION} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xMINI_LIST_ITEM} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xTASK_PARAMTERS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b xTIME_OUT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b asf.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Autogenerated API include file for the Atmel Software Framework (ASF) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b FreeRTOS.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b FreeRTOSConfig.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b heap_2.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b list.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b mpu_wrappers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b partest.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b port.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b portable.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b portmacro.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b projdefs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b queue.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b queue.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b StackMacros.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b task.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b tasks.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b timers.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b timers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/boards/{\b board.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard board header file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/{\b interrupt.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8- and 32-bit AVR })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/{\b parts.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atmel part identification macros })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt/{\b interrupt_avr8.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8-bit AVR })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/boards/stk600/rcx_x/{\b init.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with MEGA routing board init })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/{\b assembler.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer and utilities })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/{\b compiler.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commonly used includes, types and macros })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/{\b progmem.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program memory access })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/{\b status_codes.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Status code definitions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler/{\b gas.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer: GNU Assembler specifics })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/config/{\b conf_board.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega2560 on STK600 board configuration template })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Generic board support\par \pard\plain 
{\tc\tcl2 \v Generic board support}
{\xe \v Generic board support}
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b board_init} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function initializes the board target resources. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Base Boards\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EVK1100}\~ 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1100 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EVK1101}\~ 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EVK1101 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3C_EK}\~ 3\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3C UC3C_EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EVK1104}\~ 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A3 EVK1104 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EVK1105}\~ 5\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1105 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L0}\~ 6\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3L0 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L_EK}\~ 7\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3L-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XPLAIN}\~ 8\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC064X}\~ 10\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3 STK600 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC100X}\~ 11\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 STK600 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3_A3_XPLAINED}\~ 13\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3A3 UC3-A3 Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3_L0_XPLAINED}\~ 15\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3D}\~ 16\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3D board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3C0}\~ 17\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3C board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_B1_XPLAINED}\~ 18\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128B1 Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A1_XPLAINED}\~ 19\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain-A1 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L4}\~ 21\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL4 STK600 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3_L0_XPLAINED_BC}\~ 22\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board controller board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA1284P_XPLAINED_BC}\~ 23\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P-Xplained board controller board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC044X}\~ 24\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC044X routing card board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3B0}\~ 25\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3B0 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3_L0_QT600}\~ 26\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 UC3L0 MCU board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A3BU_XPLAINED}\~ 27\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3BU Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC064X_LCDX}\~ 28\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB3 STK600 RC064X LCDX board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC100X_LCDX}\~ 29\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB1 STK600 RC100X LCDX board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3B_BOARD_CONTROLLER}\~ 30\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B1 board controller for Atmel boards. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RZ600}\~ 31\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A RZ600 MCU board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S_EK}\~ 32\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3U_EK}\~ 33\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3U-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3X_EK}\~ 34\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3X-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3N_EK}\~ 35\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3N-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S_EK2}\~ 36\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK2 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S_EK}\~ 37\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3A0}\~ 38\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3A0 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_MEGA}\~ 39\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_1284P_XPLAINED}\~ 40\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S_XPLAINED}\~ 41\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATXMEGA128A1_QT600}\~ 42\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 ATXMEGA128A1 MCU board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARDUINO_DUE_X}\~ 43\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arduino Due/X board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L3}\~ 44\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL3 STK600 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4L_EK}\~ 45\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4L-EK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_MEGA_RF}\~ 46\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA RF EVK board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_C3_XPLAINED}\~ 47\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega384C3 Xplained board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STK600_RC032X}\~ 48\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC032X routing card board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S_EK2}\~ 49\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK2 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SIMULATOR_XMEGA_A1}\~ 97\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simulator for XMEGA A1 devices. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AVR_SIMULATOR_UC3}\~ 98\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR SIMULATOR for AVR UC3 device family. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_BOARD}\~ 99\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User-reserved board (if any). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DUMMY_BOARD}\~ 100\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Extension Boards\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXT1102}\~ 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EXT1102 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC300}\~ 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3 MC300 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_1}\~ 3\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 1. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_2}\~ 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 2. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_PRESSURE_1}\~ 5\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained pressure sensor board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_LIGHTPROX_1}\~ 6\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained light & proximity sensor board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_A1}\~ 7\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board "A". }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF231}\~ 8\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF230B}\~ 9\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF212}\~ 10\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_BREADBOARD}\~ 11\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained sensor development breadboard. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECURITY_XPLAINED}\~ 12\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained ATSHA204 board. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_EXT_BOARD}\~ 99\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic board support module includes board-specific definitions and function prototypes, such as the board initialization function. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARDUINO_DUE_X\:Generic board support}
{\xe \v Generic board support\:ARDUINO_DUE_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARDUINO_DUE_X\~ 43}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arduino Due/X board. }}\par
}
{\xe \v ATXMEGA128A1_QT600\:Generic board support}
{\xe \v Generic board support\:ATXMEGA128A1_QT600}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATXMEGA128A1_QT600\~ 42}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 ATXMEGA128A1 MCU board. }}\par
}
{\xe \v AVR_SIMULATOR_UC3\:Generic board support}
{\xe \v Generic board support\:AVR_SIMULATOR_UC3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AVR_SIMULATOR_UC3\~ 98}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR SIMULATOR for AVR UC3 device family. }}\par
}
{\xe \v DUMMY_BOARD\:Generic board support}
{\xe \v Generic board support\:DUMMY_BOARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DUMMY_BOARD\~ 100}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dummy board to support board-independent applications (e.g. bootloader) \par
}}
{\xe \v EVK1100\:Generic board support}
{\xe \v Generic board support\:EVK1100}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EVK1100\~ 1}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1100 board. }}\par
}
{\xe \v EVK1101\:Generic board support}
{\xe \v Generic board support\:EVK1101}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EVK1101\~ 2}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EVK1101 board. }}\par
}
{\xe \v EVK1104\:Generic board support}
{\xe \v Generic board support\:EVK1104}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EVK1104\~ 4}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A3 EVK1104 board. }}\par
}
{\xe \v EVK1105\:Generic board support}
{\xe \v Generic board support\:EVK1105}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EVK1105\~ 5}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1105 board. }}\par
}
{\xe \v EXT1102\:Generic board support}
{\xe \v Generic board support\:EXT1102}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXT1102\~ 1}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EXT1102 board. }}\par
}
{\xe \v MC300\:Generic board support}
{\xe \v Generic board support\:MC300}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC300\~ 2}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3 MC300 board. }}\par
}
{\xe \v MEGA1284P_XPLAINED_BC\:Generic board support}
{\xe \v Generic board support\:MEGA1284P_XPLAINED_BC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA1284P_XPLAINED_BC\~ 23}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P-Xplained board controller board. }}\par
}
{\xe \v MEGA_1284P_XPLAINED\:Generic board support}
{\xe \v Generic board support\:MEGA_1284P_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_1284P_XPLAINED\~ 40}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P Xplained board. }}\par
}
{\xe \v RZ600\:Generic board support}
{\xe \v Generic board support\:RZ600}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RZ600\~ 31}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A RZ600 MCU board. }}\par
}
{\xe \v RZ600_AT86RF212\:Generic board support}
{\xe \v Generic board support\:RZ600_AT86RF212}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RZ600_AT86RF212\~ 10}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }}\par
}
{\xe \v RZ600_AT86RF230B\:Generic board support}
{\xe \v Generic board support\:RZ600_AT86RF230B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RZ600_AT86RF230B\~ 9}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }}\par
}
{\xe \v RZ600_AT86RF231\:Generic board support}
{\xe \v Generic board support\:RZ600_AT86RF231}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RZ600_AT86RF231\~ 8}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }}\par
}
{\xe \v SAM3N_EK\:Generic board support}
{\xe \v Generic board support\:SAM3N_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3N_EK\~ 35}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3N-EK board. }}\par
}
{\xe \v SAM3S_EK\:Generic board support}
{\xe \v Generic board support\:SAM3S_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S_EK\~ 32}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK board. }}\par
}
{\xe \v SAM3S_EK2\:Generic board support}
{\xe \v Generic board support\:SAM3S_EK2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S_EK2\~ 36}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK2 board. }}\par
}
{\xe \v SAM3U_EK\:Generic board support}
{\xe \v Generic board support\:SAM3U_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3U_EK\~ 33}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3U-EK board. }}\par
}
{\xe \v SAM3X_EK\:Generic board support}
{\xe \v Generic board support\:SAM3X_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3X_EK\~ 34}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3X-EK board. }}\par
}
{\xe \v SAM4L_EK\:Generic board support}
{\xe \v Generic board support\:SAM4L_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4L_EK\~ 45}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4L-EK board. }}\par
}
{\xe \v SAM4S_EK\:Generic board support}
{\xe \v Generic board support\:SAM4S_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S_EK\~ 37}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK board. }}\par
}
{\xe \v SAM4S_EK2\:Generic board support}
{\xe \v Generic board support\:SAM4S_EK2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S_EK2\~ 49}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK2 board. }}\par
}
{\xe \v SAM4S_XPLAINED\:Generic board support}
{\xe \v Generic board support\:SAM4S_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S_XPLAINED\~ 41}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S Xplained board. }}\par
}
{\xe \v SECURITY_XPLAINED\:Generic board support}
{\xe \v Generic board support\:SECURITY_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECURITY_XPLAINED\~ 12}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained ATSHA204 board. }}\par
}
{\xe \v SENSORS_XPLAINED_BREADBOARD\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_BREADBOARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_BREADBOARD\~ 11}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained sensor development breadboard. }}\par
}
{\xe \v SENSORS_XPLAINED_INERTIAL_1\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_INERTIAL_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_INERTIAL_1\~ 3}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 1. }}\par
}
{\xe \v SENSORS_XPLAINED_INERTIAL_2\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_INERTIAL_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_INERTIAL_2\~ 4}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 2. }}\par
}
{\xe \v SENSORS_XPLAINED_INERTIAL_A1\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_INERTIAL_A1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_INERTIAL_A1\~ 7}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board "A". }}\par
}
{\xe \v SENSORS_XPLAINED_LIGHTPROX_1\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_LIGHTPROX_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_LIGHTPROX_1\~ 6}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained light & proximity sensor board. }}\par
}
{\xe \v SENSORS_XPLAINED_PRESSURE_1\:Generic board support}
{\xe \v Generic board support\:SENSORS_XPLAINED_PRESSURE_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SENSORS_XPLAINED_PRESSURE_1\~ 5}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained pressure sensor board. }}\par
}
{\xe \v SIMULATOR_XMEGA_A1\:Generic board support}
{\xe \v Generic board support\:SIMULATOR_XMEGA_A1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SIMULATOR_XMEGA_A1\~ 97}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simulator for XMEGA A1 devices. }}\par
}
{\xe \v STK600_MEGA\:Generic board support}
{\xe \v Generic board support\:STK600_MEGA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_MEGA\~ 39}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA board. }}\par
}
{\xe \v STK600_MEGA_RF\:Generic board support}
{\xe \v Generic board support\:STK600_MEGA_RF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_MEGA_RF\~ 46}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA RF EVK board. }}\par
}
{\xe \v STK600_RC032X\:Generic board support}
{\xe \v Generic board support\:STK600_RC032X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC032X\~ 48}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC032X routing card board. }}\par
}
{\xe \v STK600_RC044X\:Generic board support}
{\xe \v Generic board support\:STK600_RC044X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC044X\~ 24}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC044X routing card board. }}\par
}
{\xe \v STK600_RC064X\:Generic board support}
{\xe \v Generic board support\:STK600_RC064X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC064X\~ 10}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3 STK600 board. }}\par
}
{\xe \v STK600_RC064X_LCDX\:Generic board support}
{\xe \v Generic board support\:STK600_RC064X_LCDX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC064X_LCDX\~ 28}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB3 STK600 RC064X LCDX board. }}\par
}
{\xe \v STK600_RC100X\:Generic board support}
{\xe \v Generic board support\:STK600_RC100X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC100X\~ 11}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 STK600 board. }}\par
}
{\xe \v STK600_RC100X_LCDX\:Generic board support}
{\xe \v Generic board support\:STK600_RC100X_LCDX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RC100X_LCDX\~ 29}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB1 STK600 RC100X LCDX board. }}\par
}
{\xe \v STK600_RCUC3A0\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3A0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3A0\~ 38}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3A0 board. }}\par
}
{\xe \v STK600_RCUC3B0\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3B0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3B0\~ 25}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3B0 board. }}\par
}
{\xe \v STK600_RCUC3C0\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3C0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3C0\~ 17}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3C board. }}\par
}
{\xe \v STK600_RCUC3D\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3D\~ 16}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3D board. }}\par
}
{\xe \v STK600_RCUC3L0\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3L0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3L0\~ 6}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3L0 board. }}\par
}
{\xe \v STK600_RCUC3L3\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3L3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3L3\~ 44}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL3 STK600 board. }}\par
}
{\xe \v STK600_RCUC3L4\:Generic board support}
{\xe \v Generic board support\:STK600_RCUC3L4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STK600_RCUC3L4\~ 21}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL4 STK600 board. }}\par
}
{\xe \v UC3_A3_XPLAINED\:Generic board support}
{\xe \v Generic board support\:UC3_A3_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3_A3_XPLAINED\~ 13}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3A3 UC3-A3 Xplained board. }}\par
}
{\xe \v UC3_L0_QT600\:Generic board support}
{\xe \v Generic board support\:UC3_L0_QT600}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3_L0_QT600\~ 26}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 UC3L0 MCU board. }}\par
}
{\xe \v UC3_L0_XPLAINED\:Generic board support}
{\xe \v Generic board support\:UC3_L0_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3_L0_XPLAINED\~ 15}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board. }}\par
}
{\xe \v UC3_L0_XPLAINED_BC\:Generic board support}
{\xe \v Generic board support\:UC3_L0_XPLAINED_BC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3_L0_XPLAINED_BC\~ 22}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board controller board. }}\par
}
{\xe \v UC3B_BOARD_CONTROLLER\:Generic board support}
{\xe \v Generic board support\:UC3B_BOARD_CONTROLLER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3B_BOARD_CONTROLLER\~ 30}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B1 board controller for Atmel boards. }}\par
}
{\xe \v UC3C_EK\:Generic board support}
{\xe \v Generic board support\:UC3C_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3C_EK\~ 3}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3C UC3C_EK board. }}\par
}
{\xe \v UC3L_EK\:Generic board support}
{\xe \v Generic board support\:UC3L_EK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L_EK\~ 7}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3L-EK board. }}\par
}
{\xe \v USER_BOARD\:Generic board support}
{\xe \v Generic board support\:USER_BOARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_BOARD\~ 99}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User-reserved board (if any). }}\par
}
{\xe \v USER_EXT_BOARD\:Generic board support}
{\xe \v Generic board support\:USER_EXT_BOARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_EXT_BOARD\~ 99}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User-reserved extension board (if any). \par
}}
{\xe \v XMEGA_A1_XPLAINED\:Generic board support}
{\xe \v Generic board support\:XMEGA_A1_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A1_XPLAINED\~ 19}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain-A1 board. }}\par
}
{\xe \v XMEGA_A3BU_XPLAINED\:Generic board support}
{\xe \v Generic board support\:XMEGA_A3BU_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A3BU_XPLAINED\~ 27}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3BU Xplained board. }}\par
}
{\xe \v XMEGA_B1_XPLAINED\:Generic board support}
{\xe \v Generic board support\:XMEGA_B1_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_B1_XPLAINED\~ 18}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128B1 Xplained board. }}\par
}
{\xe \v XMEGA_C3_XPLAINED\:Generic board support}
{\xe \v Generic board support\:XMEGA_C3_XPLAINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_C3_XPLAINED\~ 47}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega384C3 Xplained board. }}\par
}
{\xe \v XPLAIN\:Generic board support}
{\xe \v Generic board support\:XPLAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XPLAIN\~ 8}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain board. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v board_init\:Generic board support}
{\xe \v Generic board support\:board_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void board_init (void )}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function initializes the board target resources. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function should be called to ensure proper initialization of the target board hardware connected to the part. \par
}}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Global interrupt management\par \pard\plain 
{\tc\tcl2 \v Global interrupt management}
{\xe \v Global interrupt management}
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Modules\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Deprecated interrupt definitions}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Global interrupt flags\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint8_t {\b irqflags_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type used for holding state of interrupt flag. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_enable}()\~ __enable_interrupt()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable interrupts globally. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_disable}()\~ __disable_interrupt()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable interrupts globally. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_is_enabled}()\~ cpu_irq_is_enabled_flags(SREG)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if interrupts are globally enabled. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a driver for global enabling and disabling of interrupts. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v cpu_irq_disable\:Global interrupt management}
{\xe \v Global interrupt management\:cpu_irq_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define cpu_irq_disable()\~ __disable_interrupt()}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable interrupts globally. }}\par
}
{\xe \v cpu_irq_enable\:Global interrupt management}
{\xe \v Global interrupt management\:cpu_irq_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define cpu_irq_enable()\~ __enable_interrupt()}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable interrupts globally. }}\par
}
{\xe \v cpu_irq_is_enabled\:Global interrupt management}
{\xe \v Global interrupt management\:cpu_irq_is_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define cpu_irq_is_enabled()\~ cpu_irq_is_enabled_flags(SREG)}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if interrupts are globally enabled. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid True if interrupts are enabled. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v irqflags_t\:Global interrupt management}
{\xe \v Global interrupt management\:irqflags_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b irqflags_t}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type used for holding state of interrupt flag. }}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Deprecated interrupt definitions\par \pard\plain 
{\tc\tcl2 \v Deprecated interrupt definitions}
{\xe \v Deprecated interrupt definitions}
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Enable_global_interrupt}()\~ {\b cpu_irq_enable}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Disable_global_interrupt}()\~ {\b cpu_irq_disable}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Is_global_interrupt_enabled}()\~ {\b cpu_irq_is_enabled}()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v Disable_global_interrupt\:Deprecated interrupt definitions}
{\xe \v Deprecated interrupt definitions\:Disable_global_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Disable_global_interrupt()\~ {\b cpu_irq_disable}()}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Enable_global_interrupt\:Deprecated interrupt definitions}
{\xe \v Deprecated interrupt definitions\:Enable_global_interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Enable_global_interrupt()\~ {\b cpu_irq_enable}()}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Is_global_interrupt_enabled\:Deprecated interrupt definitions}
{\xe \v Deprecated interrupt definitions\:Is_global_interrupt_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Is_global_interrupt_enabled()\~ {\b cpu_irq_is_enabled}()}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Atmel part identification macros\par \pard\plain 
{\tc\tcl2 \v Atmel part identification macros}
{\xe \v Atmel part identification macros}
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Modules\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AVR UC3 parts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AVR XMEGA parts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b megaAVR parts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tinyAVR parts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SAM parts}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Convenience macros for part checking\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AVR8_PART_IS_DEFINED}(part)\~ (defined(__ ## part ## __) || defined(__AVR_ ## part ## __))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AVR32_PART_IS_DEFINED}(part)\~ (defined(__AT32 ## part ## __) || defined(__AVR32_ ## part ## __))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM_PART_IS_DEFINED}(part)\~ (defined(__ ## part ## __))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This collection of macros identify which series and families that the various Atmel parts belong to. These can be used to select part-dependent sections of code at compile time. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AVR32_PART_IS_DEFINED\:Atmel part identification macros}
{\xe \v Atmel part identification macros\:AVR32_PART_IS_DEFINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AVR32_PART_IS_DEFINED( part)\~ (defined(__AT32 ## part ## __) || defined(__AVR32_ ## part ## __))}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AVR8_PART_IS_DEFINED\:Atmel part identification macros}
{\xe \v Atmel part identification macros\:AVR8_PART_IS_DEFINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AVR8_PART_IS_DEFINED( part)\~ (defined(__ ## part ## __) || defined(__AVR_ ## part ## __))}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SAM_PART_IS_DEFINED\:Atmel part identification macros}
{\xe \v Atmel part identification macros\:SAM_PART_IS_DEFINED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM_PART_IS_DEFINED( part)\~ (defined(__ ## part ## __))}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AVR UC3 parts\par \pard\plain 
{\tc\tcl2 \v AVR UC3 parts}
{\xe \v AVR UC3 parts}
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3}\~ ({\b UC3A} || {\b UC3B} || {\b UC3C} || {\b UC3D} || {\b UC3L})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 A series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3A0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3A1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3A3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3A4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 B series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3B0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3B1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 C series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3C0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3C1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3C2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 D series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3D3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3D4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 L series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L0128}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L0256}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L3_L4}\~ ({\b UC3L3} || {\b UC3L4})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR UC3 families\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3A}\~ ({\b UC3A0} || {\b UC3A1} || {\b UC3A3} || {\b UC3A4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3B}\~ ({\b UC3B0} || {\b UC3B1})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3C}\~ ({\b UC3C0} || {\b UC3C1} || {\b UC3C2})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3D}\~ ({\b UC3D3} || {\b UC3D4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3L}\~ ({\b UC3L0} || {\b UC3L0128} || {\b UC3L0256} || {\b UC3L3_L4})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v UC3\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3\~ ({\b UC3A} || {\b UC3B} || {\b UC3C} || {\b UC3D} || {\b UC3L})}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 product line \par
}}
{\xe \v UC3A\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3A\~ ({\b UC3A0} || {\b UC3A1} || {\b UC3A3} || {\b UC3A4})}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 A family \par
}}
{\xe \v UC3A0\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3A0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3A0}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3A0128) || \\\par
        AVR32_PART_IS_DEFINED(UC3A0256) || \\\par
        AVR32_PART_IS_DEFINED(UC3A0512) \\\par
        )\par
}
}
{\xe \v UC3A1\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3A1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3A1}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3A1128) || \\\par
        AVR32_PART_IS_DEFINED(UC3A1256) || \\\par
        AVR32_PART_IS_DEFINED(UC3A1512) \\\par
        )\par
}
}
{\xe \v UC3A3\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3A3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3A3}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3A364)   || \\\par
        AVR32_PART_IS_DEFINED(UC3A364S)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A3128)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A3128S) || \\\par
        AVR32_PART_IS_DEFINED(UC3A3256)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A3256S) \\\par
        )\par
}
}
{\xe \v UC3A4\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3A4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3A4}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3A464)   || \\\par
        AVR32_PART_IS_DEFINED(UC3A464S)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A4128)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A4128S) || \\\par
        AVR32_PART_IS_DEFINED(UC3A4256)  || \\\par
        AVR32_PART_IS_DEFINED(UC3A4256S) \\\par
        )\par
}
}
{\xe \v UC3B\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3B\~ ({\b UC3B0} || {\b UC3B1})}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 B family \par
}}
{\xe \v UC3B0\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3B0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3B0}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3B064)  || \\\par
        AVR32_PART_IS_DEFINED(UC3B0128) || \\\par
        AVR32_PART_IS_DEFINED(UC3B0256) || \\\par
        AVR32_PART_IS_DEFINED(UC3B0512) \\\par
        )\par
}
}
{\xe \v UC3B1\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3B1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3B1}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3B164)  || \\\par
        AVR32_PART_IS_DEFINED(UC3B1128) || \\\par
        AVR32_PART_IS_DEFINED(UC3B1256) || \\\par
        AVR32_PART_IS_DEFINED(UC3B1512) \\\par
        )\par
}
}
{\xe \v UC3C\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3C\~ ({\b UC3C0} || {\b UC3C1} || {\b UC3C2})}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 C family \par
}}
{\xe \v UC3C0\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3C0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3C0}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3C064C)  || \\\par
        AVR32_PART_IS_DEFINED(UC3C0128C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C0256C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C0512C) \\\par
        )\par
}
}
{\xe \v UC3C1\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3C1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3C1}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3C164C)  || \\\par
        AVR32_PART_IS_DEFINED(UC3C1128C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C1256C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C1512C) \\\par
        )\par
}
}
{\xe \v UC3C2\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3C2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3C2}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3C264C)  || \\\par
        AVR32_PART_IS_DEFINED(UC3C2128C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C2256C) || \\\par
        AVR32_PART_IS_DEFINED(UC3C2512C) \\\par
        )\par
}
}
{\xe \v UC3D\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3D\~ ({\b UC3D3} || {\b UC3D4})}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 D family \par
}}
{\xe \v UC3D3\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3D3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3D3}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC64D3)  || \\\par
        AVR32_PART_IS_DEFINED(UC128D3) \\\par
        )\par
}
}
{\xe \v UC3D4\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3D4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3D4}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC64D4)  || \\\par
        AVR32_PART_IS_DEFINED(UC128D4) \\\par
        )\par
}
}
{\xe \v UC3L\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L\~ ({\b UC3L0} || {\b UC3L0128} || {\b UC3L0256} || {\b UC3L3_L4})}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR UC3 L family \par
}}
{\xe \v UC3L0\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L0}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC3L016) || \\\par
        AVR32_PART_IS_DEFINED(UC3L032) || \\\par
        AVR32_PART_IS_DEFINED(UC3L064) \\\par
        )\par
}
}
{\xe \v UC3L0128\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L0128}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L0128}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR32_PART_IS_DEFINED(UC3L0128) \\\par
        )\par
}
}
{\xe \v UC3L0256\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L0256}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L0256}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR32_PART_IS_DEFINED(UC3L0256) \\\par
        )\par
}
}
{\xe \v UC3L3\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L3}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC64L3U)  || \\\par
        AVR32_PART_IS_DEFINED(UC128L3U) || \\\par
        AVR32_PART_IS_DEFINED(UC256L3U) \\\par
        )\par
}
}
{\xe \v UC3L3_L4\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L3_L4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L3_L4\~ ({\b UC3L3} || {\b UC3L4})}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UC3L4\:AVR UC3 parts}
{\xe \v AVR UC3 parts\:UC3L4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UC3L4}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (   \\\par
        AVR32_PART_IS_DEFINED(UC64L4U)  || \\\par
        AVR32_PART_IS_DEFINED(UC128L4U) || \\\par
        AVR32_PART_IS_DEFINED(UC256L4U) \\\par
        )\par
}
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AVR XMEGA parts\par \pard\plain 
{\tc\tcl2 \v AVR XMEGA parts}
{\xe \v AVR XMEGA parts}
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA}\~ ({\b XMEGA_A} || {\b XMEGA_AU} || {\b XMEGA_B} || {\b XMEGA_C} || {\b XMEGA_D} || {\b XMEGA_E})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA A series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A3B}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA AU series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A1U}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A3U}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A3BU}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A4U}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA B series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_B1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_B3}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA C series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_C3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_C4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA D series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_D3}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_D4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA E series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_E5}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
AVR XMEGA families\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_A}\~ ({\b XMEGA_A1} || {\b XMEGA_A3} || {\b XMEGA_A3B} || {\b XMEGA_A4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_AU}\~ ({\b XMEGA_A1U} || {\b XMEGA_A3U} || {\b XMEGA_A3BU} || {\b XMEGA_A4U})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_B}\~ ({\b XMEGA_B1} || {\b XMEGA_B3})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_C}\~ ({\b XMEGA_C3} || {\b XMEGA_C4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_D}\~ ({\b XMEGA_D3} || {\b XMEGA_D4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA_E}\~ ({\b XMEGA_E5})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v XMEGA\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA\~ ({\b XMEGA_A} || {\b XMEGA_AU} || {\b XMEGA_B} || {\b XMEGA_C} || {\b XMEGA_D} || {\b XMEGA_E})}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA product line \par
}}
{\xe \v XMEGA_A\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A\~ ({\b XMEGA_A1} || {\b XMEGA_A3} || {\b XMEGA_A3B} || {\b XMEGA_A4})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA A family \par
}}
{\xe \v XMEGA_A1\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A1}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64A1)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128A1) \\\par
        )\par
}
}
{\xe \v XMEGA_A1U\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A1U}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A1U}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64A1U)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128A1U) \\\par
        )\par
}
}
{\xe \v XMEGA_A3\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A3}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64A3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128A3) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega192A3) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega256A3) \\\par
        )\par
}
}
{\xe \v XMEGA_A3B\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A3B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A3B}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega256A3B) \\\par
        )\par
}
}
{\xe \v XMEGA_A3BU\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A3BU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A3BU}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega256A3BU) \\\par
        )\par
}
}
{\xe \v XMEGA_A3U\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A3U}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A3U}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64A3U)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128A3U) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega192A3U) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega256A3U) \\\par
        )\par
}
}
{\xe \v XMEGA_A4\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A4}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega16A4) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega32A4) \\\par
        )\par
}
}
{\xe \v XMEGA_A4U\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_A4U}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_A4U}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega16A4U)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega32A4U)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega64A4U)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128A4U) \\\par
        )\par
}
}
{\xe \v XMEGA_AU\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_AU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_AU\~ ({\b XMEGA_A1U} || {\b XMEGA_A3U} || {\b XMEGA_A3BU} || {\b XMEGA_A4U})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA AU family \par
}}
{\xe \v XMEGA_B\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_B\~ ({\b XMEGA_B1} || {\b XMEGA_B3})}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA B family \par
}}
{\xe \v XMEGA_B1\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_B1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_B1}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64B1)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128B1) \\\par
        )\par
}
}
{\xe \v XMEGA_B3\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_B3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_B3}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64B3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128B3) \\\par
        )\par
}
}
{\xe \v XMEGA_C\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_C\~ ({\b XMEGA_C3} || {\b XMEGA_C4})}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA C family \par
}}
{\xe \v XMEGA_C3\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_C3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_C3}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega384C3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega256C3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128C3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega64C3) \\\par
        )\par
}
}
{\xe \v XMEGA_C4\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_C4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_C4}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega32C4)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega16C4) \\\par
        )\par
}
}
{\xe \v XMEGA_D\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_D\~ ({\b XMEGA_D3} || {\b XMEGA_D4})}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA D family \par
}}
{\xe \v XMEGA_D3\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_D3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_D3}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega64D3)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128D3) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega192D3) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega256D3) || \\\par
        AVR8_PART_IS_DEFINED(ATxmega384D3) \\\par
        )\par
}
}
{\xe \v XMEGA_D4\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_D4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_D4}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega16D4)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega32D4)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega64D4)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega128D4) \\\par
        )\par
}
}
{\xe \v XMEGA_E\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_E\~ ({\b XMEGA_E5})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR XMEGA E family \par
}}
{\xe \v XMEGA_E5\:AVR XMEGA parts}
{\xe \v AVR XMEGA parts\:XMEGA_E5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XMEGA_E5}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATxmega8E5)   || \\\par
        AVR8_PART_IS_DEFINED(ATxmega16E5)  || \\\par
        AVR8_PART_IS_DEFINED(ATxmega32E5)     \\\par
    )\par
}
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
megaAVR parts\par \pard\plain 
{\tc\tcl2 \v megaAVR parts}
{\xe \v megaAVR parts}
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
ATmegaxx0/xx1 subgroups\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX1}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
megaAVR groups\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX0_1}\~ ({\b MEGA_XX0} || {\b MEGA_XX1})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX4_A}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX8_A}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX_A}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_RF}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
ATmegaxx_un0/un1/un2 subgroups\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_UNCATEGORIZED}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA_UNSPECIFIED}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid These megaAVR groupings are based on the groups in AVR Libc for the part header files. They are not names of official megaAVR device series or families. \par
}}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MEGA\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (MEGA_XX0_1 || MEGA_XX4 || MEGA_XX8 || MEGA_XX || MEGA_RF || \\\par
    MEGA_UNSPECIFIED)\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
megaAVR product line \par
}}
{\xe \v MEGA_RF\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_RF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_RF}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega128RFA1) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxxRF group \par
}}
{\xe \v MEGA_UNCATEGORIZED\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_UNCATEGORIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_UNCATEGORIZED}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Devices added to complete megaAVR offering. Please do not use this group symbol as it is not intended to be permanent: the devices should be regrouped. \par
}}
{\xe \v MEGA_UNSPECIFIED\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_UNSPECIFIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_UNSPECIFIED}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (MEGA_XX_UN0 || MEGA_XX_UN1 || MEGA_XX_UN2 || \\\par
    MEGA_UNCATEGORIZED)\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unspecified group \par
}}
{\xe \v MEGA_XX\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega16)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega16A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega32)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega32A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega64)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega64A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega128)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega128A) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx group \par
}}
{\xe \v MEGA_XX0\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX0}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega640)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega1280) || \\\par
        AVR8_PART_IS_DEFINED(ATmega2560) \\\par
        )\par
}
}
{\xe \v MEGA_XX0_1\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX0_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX0_1\~ ({\b MEGA_XX0} || {\b MEGA_XX1})}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx0/xx1 group \par
}}
{\xe \v MEGA_XX1\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX1}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega1281) || \\\par
        AVR8_PART_IS_DEFINED(ATmega2561) \\\par
        )\par
}
}
{\xe \v MEGA_XX4\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX4}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega164A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega164PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega324A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega324PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega644)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega644A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega644PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega1284P)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega128RFA1) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx4 group \par
}}
{\xe \v MEGA_XX4_A\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX4_A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX4_A}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega164A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega164PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega324A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega324PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega644A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega644PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega1284P) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx4 group \par
}}
{\xe \v MEGA_XX8\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX8}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega48)    || \\\par
        AVR8_PART_IS_DEFINED(ATmega48A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega48PA)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega88)    || \\\par
        AVR8_PART_IS_DEFINED(ATmega88A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega88PA)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega168)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega168A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega168PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega328)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega328P) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx8 group \par
}}
{\xe \v MEGA_XX8_A\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX8_A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX8_A}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega48A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega48PA)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega88A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega88PA)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega168A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega168PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega328P) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx8A/P/PA group \par
}}
{\xe \v MEGA_XX_A\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX_A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX_A}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega16A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega32A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega64A)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega128A) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxxA/P/PA group \par
}}
{\xe \v MEGA_XX_UN0\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX_UN0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX_UN0}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega16)    || \\\par
        AVR8_PART_IS_DEFINED(ATmega16A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega32)    || \\\par
        AVR8_PART_IS_DEFINED(ATmega32A) \\\par
        )\par
}
}
{\xe \v MEGA_XX_UN1\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX_UN1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX_UN1}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega64)    || \\\par
        AVR8_PART_IS_DEFINED(ATmega64A)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega128)   || \\\par
        AVR8_PART_IS_DEFINED(ATmega128A) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx group without power reduction and And interrupt sense register. \par
}}
{\xe \v MEGA_XX_UN2\:megaAVR parts}
{\xe \v megaAVR parts\:MEGA_XX_UN2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEGA_XX_UN2}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        AVR8_PART_IS_DEFINED(ATmega169P)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega169PA) || \\\par
        AVR8_PART_IS_DEFINED(ATmega329P)  || \\\par
        AVR8_PART_IS_DEFINED(ATmega329PA) \\\par
        )\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmegaxx group without power reduction and And interrupt sense register. \par
}}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tinyAVR parts\par \pard\plain 
{\tc\tcl2 \v tinyAVR parts}
{\xe \v tinyAVR parts}
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TINY}\~ ({\b TINY_UNCATEGORIZED})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tinyAVR groups\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TINY_UNCATEGORIZED}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TINY\:tinyAVR parts}
{\xe \v tinyAVR parts\:TINY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TINY\~ ({\b TINY_UNCATEGORIZED})}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tinyAVR product line \par
}}
{\xe \v TINY_UNCATEGORIZED\:tinyAVR parts}
{\xe \v tinyAVR parts\:TINY_UNCATEGORIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TINY_UNCATEGORIZED}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Devices added to complete tinyAVR offering. Please do not use this group symbol as it is not intended to be permanent: the devices should be regrouped. \par
}}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SAM parts\par \pard\plain 
{\tc\tcl2 \v SAM parts}
{\xe \v SAM parts}
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM}\~ ({\b SAM3S} || {\b SAM3U} || {\b SAM3N} || {\b SAM3XA} || {\b SAM4S} || {\b SAM4L})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM3S series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3SD8}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM3U series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3U1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3U2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3U4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM3N series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3N1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3N2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3N4}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM3X series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3X4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3X8}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM3A series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3A4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3A8}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM4S series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4SA16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4SD16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4SD32}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM4L series\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4LS}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4LC}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
SAM families\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3S}\~ ({\b SAM3S1} || {\b SAM3S2} || {\b SAM3S4} || {\b SAM3S8} || {\b SAM3SD8})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3U}\~ ({\b SAM3U1} || {\b SAM3U2} || {\b SAM3U4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3N}\~ ({\b SAM3N1} || {\b SAM3N2} || {\b SAM3N4})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM3XA}\~ ({\b SAM3X4} || {\b SAM3X8} || {\b SAM3A4} || {\b SAM3A8})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4S}\~ ({\b SAM4S8} || {\b SAM4S16} || {\b SAM4SA16} || {\b SAM4SD16} || {\b SAM4SD32})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM4L}\~ ({\b SAM4LS} || {\b SAM4LC})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SAM\:SAM parts}
{\xe \v SAM parts\:SAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM\~ ({\b SAM3S} || {\b SAM3U} || {\b SAM3N} || {\b SAM3XA} || {\b SAM4S} || {\b SAM4L})}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM product line \par
}}
{\xe \v SAM3A4\:SAM parts}
{\xe \v SAM parts\:SAM3A4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3A4}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3A4C) \\\par
        )\par
}
}
{\xe \v SAM3A8\:SAM parts}
{\xe \v SAM parts\:SAM3A8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3A8}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3A8C) \\\par
        )\par
}
}
{\xe \v SAM3N\:SAM parts}
{\xe \v SAM parts\:SAM3N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3N\~ ({\b SAM3N1} || {\b SAM3N2} || {\b SAM3N4})}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3N Family \par
}}
{\xe \v SAM3N1\:SAM parts}
{\xe \v SAM parts\:SAM3N1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3N1}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3N1A) || \\\par
        SAM_PART_IS_DEFINED(SAM3N1B) || \\\par
        SAM_PART_IS_DEFINED(SAM3N1C) \\\par
        )\par
}
}
{\xe \v SAM3N2\:SAM parts}
{\xe \v SAM parts\:SAM3N2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3N2}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3N2A) || \\\par
        SAM_PART_IS_DEFINED(SAM3N2B) || \\\par
        SAM_PART_IS_DEFINED(SAM3N2C) \\\par
        )\par
}
}
{\xe \v SAM3N4\:SAM parts}
{\xe \v SAM parts\:SAM3N4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3N4}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3N4A) || \\\par
        SAM_PART_IS_DEFINED(SAM3N4B) || \\\par
        SAM_PART_IS_DEFINED(SAM3N4C) \\\par
        )\par
}
}
{\xe \v SAM3S\:SAM parts}
{\xe \v SAM parts\:SAM3S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S\~ ({\b SAM3S1} || {\b SAM3S2} || {\b SAM3S4} || {\b SAM3S8} || {\b SAM3SD8})}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S Family \par
}}
{\xe \v SAM3S1\:SAM parts}
{\xe \v SAM parts\:SAM3S1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S1}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3S1A) || \\\par
        SAM_PART_IS_DEFINED(SAM3S1B) || \\\par
        SAM_PART_IS_DEFINED(SAM3S1C) \\\par
        )\par
}
}
{\xe \v SAM3S2\:SAM parts}
{\xe \v SAM parts\:SAM3S2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S2}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3S2A) || \\\par
        SAM_PART_IS_DEFINED(SAM3S2B) || \\\par
        SAM_PART_IS_DEFINED(SAM3S2C) \\\par
        )\par
}
}
{\xe \v SAM3S4\:SAM parts}
{\xe \v SAM parts\:SAM3S4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S4}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3S4A) || \\\par
        SAM_PART_IS_DEFINED(SAM3S4B) || \\\par
        SAM_PART_IS_DEFINED(SAM3S4C) \\\par
        )\par
}
}
{\xe \v SAM3S8\:SAM parts}
{\xe \v SAM parts\:SAM3S8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3S8}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3S8B) || \\\par
        SAM_PART_IS_DEFINED(SAM3S8C) \\\par
        )\par
}
}
{\xe \v SAM3SD8\:SAM parts}
{\xe \v SAM parts\:SAM3SD8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3SD8}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3SD8B) || \\\par
        SAM_PART_IS_DEFINED(SAM3SD8C) \\\par
        )\par
}
}
{\xe \v SAM3U\:SAM parts}
{\xe \v SAM parts\:SAM3U}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3U\~ ({\b SAM3U1} || {\b SAM3U2} || {\b SAM3U4})}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3U Family \par
}}
{\xe \v SAM3U1\:SAM parts}
{\xe \v SAM parts\:SAM3U1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3U1}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3U1C) || \\\par
        SAM_PART_IS_DEFINED(SAM3U1E) \\\par
        )\par
}
}
{\xe \v SAM3U2\:SAM parts}
{\xe \v SAM parts\:SAM3U2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3U2}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3U2C) || \\\par
        SAM_PART_IS_DEFINED(SAM3U2E) \\\par
        )\par
}
}
{\xe \v SAM3U4\:SAM parts}
{\xe \v SAM parts\:SAM3U4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3U4}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3U4C) || \\\par
        SAM_PART_IS_DEFINED(SAM3U4E) \\\par
        )\par
}
}
{\xe \v SAM3X4\:SAM parts}
{\xe \v SAM parts\:SAM3X4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3X4}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3X4C) || \\\par
        SAM_PART_IS_DEFINED(SAM3X4E) \\\par
        )\par
}
}
{\xe \v SAM3X8\:SAM parts}
{\xe \v SAM parts\:SAM3X8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3X8}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM3X8C) || \\\par
        SAM_PART_IS_DEFINED(SAM3X8E) || \\\par
        SAM_PART_IS_DEFINED(SAM3X8H) \\\par
        )\par
}
}
{\xe \v SAM3XA\:SAM parts}
{\xe \v SAM parts\:SAM3XA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM3XA\~ ({\b SAM3X4} || {\b SAM3X8} || {\b SAM3A4} || {\b SAM3A8})}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3XA Family \par
}}
{\xe \v SAM4L\:SAM parts}
{\xe \v SAM parts\:SAM4L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4L\~ ({\b SAM4LS} || {\b SAM4LC})}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4L Family \par
}}
{\xe \v SAM4LC\:SAM parts}
{\xe \v SAM parts\:SAM4LC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4LC}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC2A) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC2B) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC2C) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC4A) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC4B) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LC4C) \\\par
        )\par
}
}
{\xe \v SAM4LS\:SAM parts}
{\xe \v SAM parts\:SAM4LS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4LS}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS2A) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS2B) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS2C) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS4A) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS4B) || \\\par
        SAM_PART_IS_DEFINED(ATSAM4LS4C) \\\par
        )\par
}
}
{\xe \v SAM4S\:SAM parts}
{\xe \v SAM parts\:SAM4S}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S\~ ({\b SAM4S8} || {\b SAM4S16} || {\b SAM4SA16} || {\b SAM4SD16} || {\b SAM4SD32})}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S Family \par
}}
{\xe \v SAM4S16\:SAM parts}
{\xe \v SAM parts\:SAM4S16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S16}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM4S16B) || \\\par
        SAM_PART_IS_DEFINED(SAM4S16C) \\\par
        )\par
}
}
{\xe \v SAM4S8\:SAM parts}
{\xe \v SAM parts\:SAM4S8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4S8}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM4S8B) || \\\par
        SAM_PART_IS_DEFINED(SAM4S8C) \\\par
        )\par
}
}
{\xe \v SAM4SA16\:SAM parts}
{\xe \v SAM parts\:SAM4SA16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4SA16}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM4SA16B) || \\\par
        SAM_PART_IS_DEFINED(SAM4SA16C)    \\\par
    )\par
}
}
{\xe \v SAM4SD16\:SAM parts}
{\xe \v SAM parts\:SAM4SD16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4SD16}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM4SD16B) || \\\par
        SAM_PART_IS_DEFINED(SAM4SD16C)    \\\par
    )\par
}
}
{\xe \v SAM4SD32\:SAM parts}
{\xe \v SAM parts\:SAM4SD32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAM4SD32}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( \\\par
        SAM_PART_IS_DEFINED(SAM4SD32B) || \\\par
        SAM_PART_IS_DEFINED(SAM4SD32C)    \\\par
    )\par
}
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Assembler Support\par \pard\plain 
{\tc\tcl2 \v Assembler Support}
{\xe \v Assembler Support}
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Control Statements\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REPEAT}(count)\~ .rept   count\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Repeat the following statements {\i count}  times. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_REPEAT}()\~ .endr\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the statements to be repeated. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SET_LOC}(offset)\~ .org    offset\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the location counter to {\i offset} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_FILE}()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the file. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Objects\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FILL_BYTES}(count)\~ .fill   count\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate space for {\i count}  bytes. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Symbol Definition\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b L}({\b name})\~ .L##{\b name}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turn {\i name}  into a local symbol, if possible. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTERN_SYMBOL}({\b name})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare {\i name}  as an external symbol referenced by this file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FUNCTION}({\b name})\~ gas_begin_func {\b name} 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a file-local function called {\i name} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PUBLIC_FUNCTION}({\b name})\~ gas_begin_func {\b name} 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a globally visible function called {\i name} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WEAK_FUNCTION}({\b name})\~ gas_weak_function {\b name}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a weak function called {\i name} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WEAK_FUNCTION_ALIAS}({\b name}, strong_name)\~ gas_weak_function_alias {\b name} strong_name\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define {\i name}  as a weak alias for the function {\i strong_name} . }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_FUNC}({\b name})\~ .size   {\b name}, . - {\b name}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the function called {\i name} . }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Section Definition\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEXT_SECTION}({\b name})\~ .section {\b name}, "ax", @progbits\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing executable code. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RODATA_SECTION}({\b name})\~ .section {\b name}, "a", @progbits\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing read-only data. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DATA_SECTION}({\b name})\~ .section {\b name}, "aw", @progbits\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable initialized data. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BSS_SECTION}({\b name})\~ .section {\b name}, "aw", @nobits\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable zero-initialized data. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This group provides a good handful of macros intended to smooth out the differences between various assemblers, similar to what {\b compiler.h} does for compilers, except that assemblers tend to be much less standardized than compilers. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BSS_SECTION\:Assembler Support}
{\xe \v Assembler Support\:BSS_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BSS_SECTION( {\b name})\~ .section {\b name}, "aw", @nobits}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable zero-initialized data. }}\par
}
{\xe \v DATA_SECTION\:Assembler Support}
{\xe \v Assembler Support\:DATA_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DATA_SECTION( {\b name})\~ .section {\b name}, "aw", @progbits}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable initialized data. }}\par
}
{\xe \v END_FILE\:Assembler Support}
{\xe \v Assembler Support\:END_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_FILE()}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the file. }}\par
}
{\xe \v END_FUNC\:Assembler Support}
{\xe \v Assembler Support\:END_FUNC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_FUNC( {\b name})\~ .size   {\b name}, . - {\b name}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the function called {\i name} . }}\par
}
{\xe \v END_REPEAT\:Assembler Support}
{\xe \v Assembler Support\:END_REPEAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_REPEAT()\~ .endr}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the statements to be repeated. }}\par
}
{\xe \v EXTERN_SYMBOL\:Assembler Support}
{\xe \v Assembler Support\:EXTERN_SYMBOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTERN_SYMBOL( {\b name})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare {\i name}  as an external symbol referenced by this file. }}\par
}
{\xe \v FILL_BYTES\:Assembler Support}
{\xe \v Assembler Support\:FILL_BYTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FILL_BYTES( count)\~ .fill   count}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate space for {\i count}  bytes. }}\par
}
{\xe \v FUNCTION\:Assembler Support}
{\xe \v Assembler Support\:FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FUNCTION( {\b name})\~ gas_begin_func {\b name} 0}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a file-local function called {\i name} . }}\par
}
{\xe \v L\:Assembler Support}
{\xe \v Assembler Support\:L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define L( {\b name})\~ .L##{\b name}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turn {\i name}  into a local symbol, if possible. }}\par
}
{\xe \v PUBLIC_FUNCTION\:Assembler Support}
{\xe \v Assembler Support\:PUBLIC_FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PUBLIC_FUNCTION( {\b name})\~ gas_begin_func {\b name} 1}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a globally visible function called {\i name} . }}\par
}
{\xe \v REPEAT\:Assembler Support}
{\xe \v Assembler Support\:REPEAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REPEAT( count)\~ .rept   count}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Repeat the following statements {\i count}  times. }}\par
}
{\xe \v RODATA_SECTION\:Assembler Support}
{\xe \v Assembler Support\:RODATA_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RODATA_SECTION( {\b name})\~ .section {\b name}, "a", @progbits}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing read-only data. }}\par
}
{\xe \v SET_LOC\:Assembler Support}
{\xe \v Assembler Support\:SET_LOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SET_LOC( offset)\~ .org    offset}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the location counter to {\i offset} . }}\par
}
{\xe \v TEXT_SECTION\:Assembler Support}
{\xe \v Assembler Support\:TEXT_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEXT_SECTION( {\b name})\~ .section {\b name}, "ax", @progbits}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing executable code. }}\par
}
{\xe \v WEAK_FUNCTION\:Assembler Support}
{\xe \v Assembler Support\:WEAK_FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WEAK_FUNCTION( {\b name})\~ gas_weak_function {\b name}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a weak function called {\i name} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weak functions are only referenced if no strong definitions are found \par
}}
{\xe \v WEAK_FUNCTION_ALIAS\:Assembler Support}
{\xe \v Assembler Support\:WEAK_FUNCTION_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WEAK_FUNCTION_ALIAS( {\b name},  strong_name)\~ gas_weak_function_alias {\b name} strong_name}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define {\i name}  as a weak alias for the function {\i strong_name} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See Also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b WEAK_FUNCTION} \par
}}}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Program memory\par \pard\plain 
{\tc\tcl2 \v Program memory}
{\xe \v Program memory}
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xQueueCreate\par \pard\plain 
{\tc\tcl2 \v xQueueCreate}
{\xe \v xQueueCreate}
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 xQueueHandle xQueueCreate(
                              unsigned portBASE_TYPE uxQueueLength,
                              unsigned portBASE_TYPE uxItemSize
                          );
   \par}
Creates a new queue instance. This allocates the storage required by the new queue and returns a handle for the queue.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uxQueueLength} \cell }{The maximum number of items that the queue can contain.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uxItemSize} \cell }{The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid If the queue is successfully create then a handle to the newly created queue is returned. If the queue cannot be created then 0 is returned.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vATask( void *pvParameters )
 \{
 xQueueHandle xQueue1, xQueue2;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 unsigned long values.
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
    if( xQueue1 == 0 )
    \{
Queue was not created and must not be used.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
    if( xQueue2 == 0 )
    \{
Queue was not created and must not be used.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xQueueSend\par \pard\plain 
{\tc\tcl2 \v xQueueSend}
{\xe \v xQueueSend}
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSendToToFront(
                                   xQueueHandle xQueue,
                                   const void   *   pvItemToQueue,
                                   portTickType xTicksToWait
                               );
   \par}
This is a macro that calls {\b xQueueGenericSend()}.\par
Post an item to the front of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  unsigned long ulVar = 10UL;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vATask( void *pvParameters )
 \{
 xQueueHandle xQueue1, xQueue2;
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 unsigned long values.
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if( xQueue1 != 0 )\par
\{\par
}

Send an unsigned long.  Wait for 10 ticks for space to become
available if necessary.
        if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
        \{
Failed to post the message, even after 10 ticks.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue2 != 0 )
    \{
Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
        pxMessage = & xMessage;
        xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSendToBack(
                                   xQueueHandle xQueue,
                                   const    void    *   pvItemToQueue,
                                   portTickType xTicksToWait
                               );
   \par}
This is a macro that calls {\b xQueueGenericSend()}.\par
Post an item to the back of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  unsigned long ulVar = 10UL;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vATask( void *pvParameters )
 \{
 xQueueHandle xQueue1, xQueue2;
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 unsigned long values.
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if( xQueue1 != 0 )\par
\{\par
}

Send an unsigned long.  Wait for 10 ticks for space to become
available if necessary.
        if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
        \{
Failed to post the message, even after 10 ticks.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue2 != 0 )
    \{
Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
        pxMessage = & xMessage;
        xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSend(
                              xQueueHandle xQueue,
                              const void * pvItemToQueue,
                              portTickType xTicksToWait
                         );
   \par}
This is a macro that calls {\b xQueueGenericSend()}. It is included for backward compatibility with versions of FreeRTOS.org that did not include the {\b xQueueSendToFront()} and {\b xQueueSendToBack()} macros. It is equivalent to {\b xQueueSendToBack()}.\par
Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  unsigned long ulVar = 10UL;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vATask( void *pvParameters )
 \{
 xQueueHandle xQueue1, xQueue2;
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 unsigned long values.
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if( xQueue1 != 0 )\par
\{\par
}

Send an unsigned long.  Wait for 10 ticks for space to become
available if necessary.
        if( xQueueSend( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
        \{
Failed to post the message, even after 10 ticks.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue2 != 0 )
    \{
Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
        pxMessage = & xMessage;
        xQueueSend( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueGenericSend(
                                    xQueueHandle xQueue,
                                    const void * pvItemToQueue,
                                    portTickType xTicksToWait
                                    portBASE_TYPE xCopyPosition
                                );
   \par}
It is preferred that the macros {\b xQueueSend()}, {\b xQueueSendToFront()} and {\b xQueueSendToBack()} are used in place of calling this function directly.\par
Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xCopyPosition} \cell }{Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  unsigned long ulVar = 10UL;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vATask( void *pvParameters )
 \{
 xQueueHandle xQueue1, xQueue2;
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 unsigned long values.
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if( xQueue1 != 0 )\par
\{\par
}

Send an unsigned long.  Wait for 10 ticks for space to become
available if necessary.
        if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( portTickType ) 10, queueSEND_TO_BACK ) != pdPASS )
        \{
Failed to post the message, even after 10 ticks.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue2 != 0 )
    \{
Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
        pxMessage = & xMessage;
        xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0, queueSEND_TO_BACK );
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xQueueReceive\par \pard\plain 
{\tc\tcl2 \v xQueueReceive}
{\xe \v xQueueReceive}
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueuePeek(
                             xQueueHandle xQueue,
                             void *pvBuffer,
                             portTickType xTicksToWait
                         );\par}
This is a macro that calls the {\b xQueueGenericReceive()} function.\par
Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.\par
Successfully received items remain on the queue so will be returned again by the next call, or a call to {\b xQueueReceive()}.\par
This macro must not be used in an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxQueue} \cell }{The handle to the queue from which the item is to be received.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvBuffer} \cell }{Pointer to the buffer into which the received item will be copied.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required. {\b xQueuePeek()} will return immediately if xTicksToWait is 0 and the queue is empty.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  xQueueHandle xQueue;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to create a queue and post a value.
 void vATask( void *pvParameters )
 \{
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
    if( xQueue == 0 )
    \{
Failed to create the queue.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
    pxMessage = & xMessage;
    xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to peek the data from the queue.
 void vADifferentTask( void *pvParameters )
 \{
 struct AMessage *pxRxedMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue != 0 )
    \{
Peek a message on the created queue.  Block for 10 ticks if a
message is not immediately available.
        if( xQueuePeek( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
        \{
pcRxedMessage now points to the struct AMessage variable posted
by vATask, but the item still remains on the queue.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueReceive(
                                 xQueueHandle xQueue,
                                 void *pvBuffer,
                                 portTickType xTicksToWait
                            );\par}
This is a macro that calls the {\b xQueueGenericReceive()} function.\par
Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.\par
Successfully received items are removed from the queue.\par
This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxQueue} \cell }{The handle to the queue from which the item is to be received.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvBuffer} \cell }{Pointer to the buffer into which the received item will be copied.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. {\b xQueueReceive()} will return immediately if xTicksToWait is zero and the queue is empty. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  xQueueHandle xQueue;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to create a queue and post a value.
 void vATask( void *pvParameters )
 \{
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
    if( xQueue == 0 )
    \{
Failed to create the queue.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
    pxMessage = & xMessage;
    xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to receive from the queue.
 void vADifferentTask( void *pvParameters )
 \{
 struct AMessage *pxRxedMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue != 0 )
    \{
Receive a message on the created queue.  Block for 10 ticks if a
message is not immediately available.
        if( xQueueReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
        \{
pcRxedMessage now points to the struct AMessage variable posted
by vATask.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueGenericReceive(
                                       xQueueHandle xQueue,
                                       void *pvBuffer,
                                       portTickType xTicksToWait
                                       portBASE_TYPE    xJustPeek
                                    );\par}
It is preferred that the macro {\b xQueueReceive()} be used rather than calling this function directly.\par
Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.\par
This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxQueue} \cell }{The handle to the queue from which the item is to be received.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvBuffer} \cell }{Pointer to the buffer into which the received item will be copied.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToWait} \cell }{The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_RATE_MS should be used to convert to real time if this is required. {\b xQueueGenericReceive()} will return immediately if the queue is empty and xTicksToWait is 0.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xJustPeek} \cell }{When set to true, the item received from the queue is not actually removed from the queue - meaning a subsequent call to {\b xQueueReceive()} will return the same item. When set to false, the item being received from the queue is also removed from the queue.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 struct AMessage
 \{
    char ucMessageID;
    char ucData[ 20 ];
 \} xMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  xQueueHandle xQueue;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to create a queue and post a value.
 void vATask( void *pvParameters )
 \{
 struct AMessage *pxMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 pointers to AMessage structures.
These should be passed by pointer as they contain a lot of data.
    xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
    if( xQueue == 0 )
    \{
Failed to create the queue.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Send a pointer to a struct AMessage object.  Don't block if the
queue is already full.
    pxMessage = & xMessage;
    xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Task to receive from the queue.
 void vADifferentTask( void *pvParameters )
 \{
 struct AMessage *pxRxedMessage;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( xQueue != 0 )
    \{
Receive a message on the created queue.  Block for 10 ticks if a
message is not immediately available.
        if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
        \{
pcRxedMessage now points to the struct AMessage variable posted
by vATask.
        \}
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... Rest of task code.
 \}
 \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xQueueSendFromISR\par \pard\plain 
{\tc\tcl2 \v xQueueSendFromISR}
{\xe \v xQueueSendFromISR}
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSendToFrontFromISR(
                                         xQueueHandle pxQueue,
                                         const void *pvItemToQueue,
                                         portBASE_TYPE *pxHigherPriorityTaskWoken
                                      );
 \par}
This is a macro that calls {\b xQueueGenericSendFromISR()}.\par
Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.\par
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{{\b xQueueSendToFrontFromISR()} will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFromFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.\par
}Example usage for buffered IO (where the ISR can obtain more than one value per call): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vBufferISR( void )
 \{
 char cIn;
 portBASE_TYPE xHigherPrioritTaskWoken;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid We have not woken a task at the start of the ISR.
    xHigherPriorityTaskWoken = pdFALSE;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Loop until the buffer is empty.
    do
    \{
Obtain a byte from the buffer.
        cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Post the byte.
        {\b xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken )};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     \} while( portINPUT_BYTE( BUFFER_COUNT ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Now the buffer is empty we can switch context if necessary.
    if( xHigherPriorityTaskWoken )
    \{
        taskYIELD ();
    \}
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSendToBackFromISR(
                                         xQueueHandle pxQueue,
                                         const void *pvItemToQueue,
                                         portBASE_TYPE *pxHigherPriorityTaskWoken
                                      );
 \par}
This is a macro that calls {\b xQueueGenericSendFromISR()}.\par
Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.\par
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{{\b xQueueSendToBackFromISR()} will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If {\b xQueueSendToBackFromISR()} sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.\par
}Example usage for buffered IO (where the ISR can obtain more than one value per call): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vBufferISR( void )
 \{
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWoken;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid We have not woken a task at the start of the ISR.
    xHigherPriorityTaskWoken = pdFALSE;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Loop until the buffer is empty.
    do
    \{
Obtain a byte from the buffer.
        cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Post the byte.
        {\b xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken )};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     \} while( portINPUT_BYTE( BUFFER_COUNT ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Now the buffer is empty we can switch context if necessary.
    if( xHigherPriorityTaskWoken )
    \{
        taskYIELD ();
    \}
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueSendFromISR(
                                     xQueueHandle pxQueue,
                                     const void *pvItemToQueue,
                                     portBASE_TYPE *pxHigherPriorityTaskWoken
                                );
 \par}
This is a macro that calls {\b xQueueGenericSendFromISR()}. It is included for backward compatibility with versions of FreeRTOS.org that did not include the {\b xQueueSendToBackFromISR()} and {\b xQueueSendToFrontFromISR()} macros.\par
Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.\par
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{{\b xQueueSendFromISR()} will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If {\b xQueueSendFromISR()} sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.\par
}Example usage for buffered IO (where the ISR can obtain more than one value per call): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vBufferISR( void )
 \{
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWoken;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid We have not woken a task at the start of the ISR.
    xHigherPriorityTaskWoken = pdFALSE;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Loop until the buffer is empty.
    do
    \{
Obtain a byte from the buffer.
        cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Post the byte.
        {\b xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken )};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     \} while( portINPUT_BYTE( BUFFER_COUNT ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Now the buffer is empty we can switch context if necessary.
    if( xHigherPriorityTaskWoken )
    \{
Actual macro used here is port specific.
        taskYIELD_FROM_ISR ();
    \}
 \}
 \par}
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueGenericSendFromISR(
                                           xQueueHandle pxQueue,
                                           const    void    *pvItemToQueue,
                                           portBASE_TYPE    *pxHigherPriorityTaskWoken,
                                           portBASE_TYPE    xCopyPosition
                                       );
 \par}
It is preferred that the macros {\b xQueueSendFromISR()}, {\b xQueueSendToFrontFromISR()} and {\b xQueueSendToBackFromISR()} be used in place of calling this function directly.\par
Post an item on a queue. It is safe to use this function from within an interrupt service routine.\par
Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xQueue} \cell }{The handle to the queue on which the item is to be posted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvItemToQueue} \cell }{A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{{\b xQueueGenericSendFromISR()} will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If {\b xQueueGenericSendFromISR()} sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xCopyPosition} \cell }{Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.\par
}Example usage for buffered IO (where the ISR can obtain more than one value per call): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vBufferISR( void )
 \{
 char cIn;
 portBASE_TYPE xHigherPriorityTaskWokenByPost;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid We have not woken a task at the start of the ISR.
    xHigherPriorityTaskWokenByPost = pdFALSE;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Loop until the buffer is empty.
    do
    \{
Obtain a byte from the buffer.
        cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Post each byte.
        xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     \} while( portINPUT_BYTE( BUFFER_COUNT ) );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Now the buffer is empty we can switch context if necessary.  Note that the
name of the yield function required is port specific.
    if( xHigherPriorityTaskWokenByPost )
    \{
        taskYIELD_YIELD_FROM_ISR();
    \}
 \}
 \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xQueueReceiveFromISR\par \pard\plain 
{\tc\tcl2 \v xQueueReceiveFromISR}
{\xe \v xQueueReceiveFromISR}
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
queue. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xQueueReceiveFromISR(
                                       xQueueHandle pxQueue,
                                       void *pvBuffer,
                                       portBASE_TYPE    *pxTaskWoken
                                   );
   \par}
Receive an item from a queue. It is safe to use this function from within an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxQueue} \cell }{The handle to the queue from which the item is to be received.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvBuffer} \cell }{Pointer to the buffer into which the received item will be copied.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTaskWoken} \cell }{A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR causes such a task to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will remain unchanged.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  xQueueHandle xQueue;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Function to create a queue and post some values.
 void vAFunction( void *pvParameters )
 \{
 char cValueToPost;
 const portTickType xBlockTime = ( portTickType )0xff;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a queue capable of containing 10 characters.
    xQueue = xQueueCreate( 10, sizeof( char ) );
    if( xQueue == 0 )
    \{
Failed to create the queue.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Post some characters that will be used within an ISR.  If the queue
is full then this task will block for xBlockTime ticks.
    cValueToPost = 'a';
    xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );
    cValueToPost = 'b';
    xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ... keep posting characters ... this task may block when the queue
becomes full.
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cValueToPost = 'c';\par
xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );\par
}

 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ISR that outputs all the characters received on the queue.
 void vISR_Routine( void )
 \{
 portBASE_TYPE xTaskWokenByReceive = pdFALSE;
 char cRxedChar;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
    \{
A character was received.  Output the character now.
        vOutputCharacter( cRxedChar );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid If removing the character from the queue woke the task that was
posting onto the queue cTaskWokenByReceive will have been set to
pdTRUE.  No matter how many times this loop iterates only one
task will be woken.
    \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     if( cTaskWokenByPost != ( char ) pdFALSE;
    \{
        taskYIELD ();
    \}
 \}
 \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xTaskCreate\par \pard\plain 
{\tc\tcl2 \v xTaskCreate}
{\xe \v xTaskCreate}
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE xTaskCreate(
                              pdTASK_CODE pvTaskCode,
                              const char * const pcName,
                              unsigned short usStackDepth,
                              void *pvParameters,
                              unsigned portBASE_TYPE uxPriority,
                              xTaskHandle *pvCreatedTask
                          );\par}
Create a new task and add it to the list of tasks that are ready to run.\par
{\b xTaskCreate()} can only be used to create a task that has unrestricted access to the entire microcontroller memory map. Systems that include MPU support can alternatively create an MPU constrained task using {\b xTaskCreateRestricted()}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvTaskCode} \cell }{Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pcName} \cell }{A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by tskMAX_TASK_NAME_LEN - default is 16.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i usStackDepth} \cell }{The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvParameters} \cell }{Pointer that will be used as the parameter for the task being created.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uxPriority} \cell }{The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvCreatedTask} \cell }{Used to pass back a handle by which the created task can be referenced.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file errors. h\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Task to be created.
 void vTaskCode( void * pvParameters )
 \{
     for( ;; )
     \{
Task code goes here.
     \}
 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Function that creates a task.
 void vOtherFunction( void )
 \{
 static unsigned char ucParameterToPass;
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
must exist for the lifetime of the task, so in this case is declared static.  If it was just an
an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
the new task attempts to access it.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to delete the task.
     vTaskDelete( xHandle );
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xTaskCreateRestricted\par \pard\plain 
{\tc\tcl2 \v xTaskCreateRestricted}
{\xe \v xTaskCreateRestricted}
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 portBASE_TYPE {\b xTaskCreateRestricted( xTaskParameters *pxTaskDefinition, xTaskHandle *pxCreatedTask )};\par}
{\b xTaskCreateRestricted()} should only be used in systems that include an MPU implementation.\par
Create a new task and add it to the list of tasks that are ready to run. The function parameters define the memory regions and associated access permissions allocated to the task.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTaskDefinition} \cell }{Pointer to a structure that contains a member for each of the normal {\b xTaskCreate()} parameters (see the {\b xTaskCreate()} API documentation) plus an optional stack buffer and the memory region definitions.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxCreatedTask} \cell }{Used to pass back a handle by which the created task can be referenced.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file errors. h\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Create an xTaskParameters structure that defines the task to be created.
static const xTaskParameters xCheckTaskParameters =
\{
    vATask,     // pvTaskCode - the function that implements the task.
    "ATask",    // pcName - just a text name for the task to assist debugging.
    100,        // usStackDepth - the stack size DEFINED IN WORDS.
    NULL,       // pvParameters - passed into the task function as the function parameters.
    ( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
    cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid xRegions - Allocate up to three separate memory regions for access by
the task, with appropriate access permissions.  Different processors have
different memory alignment requirements - refer to the FreeRTOS documentation
for full information.
    \{                                           
Base address                    Length  Parameters
        \{ cReadWriteArray,              32,     portMPU_REGION_READ_WRITE \},
        \{ cReadOnlyArray,               32,     portMPU_REGION_READ_ONLY \},
        \{ cPrivilegedOnlyAccessArray,   128,    portMPU_REGION_PRIVILEGED_READ_WRITE \}
    \}
\};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int {\b main( void )}
\{
xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a task from the const structure defined above.  The task handle
is requested (the second parameter is not NULL) but in this case just for
demonstration purposes as its not actually used.
    {\b xTaskCreateRestricted( &xRegTest1Parameters, &xHandle )};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Start the scheduler.
    {\b vTaskStartScheduler()};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Will only get here if there was insufficient memory to create the idle
task.
    for( ;; );
\}
   \par}
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void {\b vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions )};\par}
Memory regions are assigned to a restricted task when the task is created by a call to {\b xTaskCreateRestricted()}. These regions can be redefined using {\b vTaskAllocateMPURegions()}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTask} \cell }{The handle of the task being updated.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xRegions} \cell }{A pointer to an xMemoryRegion structure that contains the new memory region definitions.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Define an array of xMemoryRegion structures that configures an MPU region
allowing read/write access for 1024 bytes starting at the beginning of the
ucOneKByte array.  The other two of the maximum 3 definable regions are
unused so set to zero.
static const xMemoryRegion xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
\{                                           
Base address        Length      Parameters
    \{ ucOneKByte,       1024,       portMPU_REGION_READ_WRITE \},
    \{ 0,                0,          0 \},
    \{ 0,                0,          0 \}
\};\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void vATask( void *pvParameters )
\{
This task was created such that it has access to certain regions of
memory as defined by the MPU configuration.  At some point it is
desired that these MPU regions are replaced with that defined in the
xAltRegions const struct above.  Use a call to {\b vTaskAllocateMPURegions()}
for this purpose.  NULL is used as the task handle to indicate that this
function should modify the MPU regions of the calling task.
    vTaskAllocateMPURegions( NULL, xAltRegions );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Now the task can continue its function, but from this point on can only
access its stack and the ucOneKByte array (unless any other statically
defined or shared regions have been declared elsewhere).
\}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskDelete\par \pard\plain 
{\tc\tcl2 \v vTaskDelete}
{\xe \v vTaskDelete}
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskDelete( xTaskHandle pxTask )};\par}
INCLUDE_vTaskDelete must be defined as 1 for this function to be available. See the configuration section for more information.\par
Remove a task from the RTOS real time kernels management. The task being deleted will be removed from all ready, blocked, suspended and event lists.\par
NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.\par
See the demo application file death.c for sample code that utilises vTaskDelete ().\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTask} \cell }{The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vOtherFunction( void )
 \{
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create the task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to delete the task.
     vTaskDelete( xHandle );
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskDelay\par \pard\plain 
{\tc\tcl2 \v vTaskDelay}
{\xe \v vTaskDelay}
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskDelay( portTickType xTicksToDelay )};\par}
Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.\par
INCLUDE_vTaskDelay must be defined as 1 for this function to be available. See the configuration section for more information.\par
{\b vTaskDelay()} specifies a time at which the task wishes to unblock relative to the time at which {\b vTaskDelay()} is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after {\b vTaskDelay()} is called. {\b vTaskDelay()} does not therefore provide a good method of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which {\b vTaskDelay()} gets called and therefore the time at which the task next executes. See {\b vTaskDelayUntil()} for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTicksToDelay} \cell }{The amount of time, in tick periods, that the calling task should block.\cell }
{\row }
}
Example usage:\par
void vTaskFunction( void * pvParameters ) \{ void vTaskFunction( void * pvParameters ) \{ Block for 500ms. const portTickType xDelay = 500 / portTICK_RATE_MS; {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for( ;; )\par
\{\par
}
 Simply toggle the LED every 500ms, blocking between each toggle. vToggleLED(); vTaskDelay( xDelay ); \} \} \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskDelayUntil\par \pard\plain 
{\tc\tcl2 \v vTaskDelayUntil}
{\xe \v vTaskDelayUntil}
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskDelayUntil( portTickType *pxPreviousWakeTime, portTickType xTimeIncrement )};\par}
INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available. See the configuration section for more information.\par
Delay a task until a specified time. This function can be used by cyclical tasks to ensure a constant execution frequency.\par
This function differs from vTaskDelay () in one important aspect: vTaskDelay () will cause a task to block for the specified number of ticks from the time vTaskDelay () is called. It is therefore difficult to use vTaskDelay () by itself to generate a fixed execution frequency as the time between a task starting to execute and that task calling vTaskDelay () may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].\par
Whereas vTaskDelay () specifies a wake time relative to the time at which the function is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to unblock.\par
The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxPreviousWakeTime} \cell }{Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil ().\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimeIncrement} \cell }{The cycle time period. The task will be unblocked at time *pxPreviousWakeTime + xTimeIncrement. Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interface period.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
Perform an action every 10 ticks.
 void vTaskFunction( void * pvParameters )
 \{
 portTickType xLastWakeTime;
 const portTickType xFrequency = 10;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Initialise the xLastWakeTime variable with the current time.
     xLastWakeTime = xTaskGetTickCount ();
     for( ;; )
     \{
Wait for the next cycle.
         vTaskDelayUntil( &xLastWakeTime, xFrequency );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Perform action here.
     \}
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uxTaskPriorityGet\par \pard\plain 
{\tc\tcl2 \v uxTaskPriorityGet}
{\xe \v uxTaskPriorityGet}
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid unsigned portBASE_TYPE {\b uxTaskPriorityGet( xTaskHandle pxTask )};\par}
INCLUDE_xTaskPriorityGet must be defined as 1 for this function to be available. See the configuration section for more information.\par
Obtain the priority of any task.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTask} \cell }{Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The priority of pxTask.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vAFunction( void )
 \{
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to obtain the priority of the created task.
It was created with tskIDLE_PRIORITY, but may have changed
it itself.
     if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
     \{
The task has changed it's priority.
     \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Is our priority higher than the created task?
     if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
     \{
Our priority (obtained using NULL handle) is higher.
     \}
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskPrioritySet\par \pard\plain 
{\tc\tcl2 \v vTaskPrioritySet}
{\xe \v vTaskPrioritySet}
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )};\par}
INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available. See the configuration section for more information.\par
Set the priority of any task.\par
A context switch will occur before the function returns if the priority being set is higher than the currently executing task.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTask} \cell }{Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uxNewPriority} \cell }{The priority to which the task will be set.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vAFunction( void )
 \{
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to raise the priority of the created task.
     vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use a NULL handle to raise our priority to the same value.
     vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskSuspend\par \pard\plain 
{\tc\tcl2 \v vTaskSuspend}
{\xe \v vTaskSuspend}
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskSuspend( xTaskHandle pxTaskToSuspend )};\par}
INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.\par
Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority.\par
Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend () twice on the same task still only requires one call to vTaskResume () to ready the suspended task.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTaskToSuspend} \cell }{Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vAFunction( void )
 \{
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to suspend the created task.
     vTaskSuspend( xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid The created task will not run during this period, unless
another task calls vTaskResume( xHandle ).\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Suspend ourselves.
     vTaskSuspend( NULL );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid We cannot get here unless another task calls vTaskResume
with our handle as the parameter.
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskResume\par \pard\plain 
{\tc\tcl2 \v vTaskResume}
{\xe \v vTaskResume}
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskResume( xTaskHandle pxTaskToResume )};\par}
INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.\par
Resumes a suspended task.\par
A task that has been suspended by one of more calls to vTaskSuspend () will be made available for running again by a single call to vTaskResume ().\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTaskToResume} \cell }{Handle to the task being readied.\cell }
{\row }
}
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vAFunction( void )
 \{
 xTaskHandle xHandle;\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Create a task, storing the handle.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Use the handle to suspend the created task.
     vTaskSuspend( xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid The created task will not run during this period, unless
another task calls vTaskResume( xHandle ).\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Resume the suspended task ourselves.
     vTaskResume( xHandle );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid The created task will once again get microcontroller processing
time in accordance with it priority within the system.
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskResumeFromISR\par \pard\plain 
{\tc\tcl2 \v vTaskResumeFromISR}
{\xe \v vTaskResumeFromISR}
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b xTaskResumeFromISR( xTaskHandle pxTaskToResume )};\par}
INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.\par
An implementation of {\b vTaskResume()} that can be called from within an ISR.\par
A task that has been suspended by one of more calls to vTaskSuspend () will be made available for running again by a single call to xTaskResumeFromISR ().\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxTaskToResume} \cell }{Handle to the task being readied. \cell }
{\row }
}
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskStartScheduler\par \pard\plain 
{\tc\tcl2 \v vTaskStartScheduler}
{\xe \v vTaskStartScheduler}
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskStartScheduler( void )};\par}
Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when. This function does not return until an executing task calls vTaskEndScheduler ().\par
At least one task should be created via a call to xTaskCreate () before calling vTaskStartScheduler (). The idle task is created automatically when the first application task is created.\par
See the demo application file {\b main.c} for an example of creating tasks and starting the kernel.\par
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vAFunction( void )
 \{
Create at least one task before starting the kernel.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Start the real time kernel with preemption.
     vTaskStartScheduler ();\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Will not get here unless a task calls vTaskEndScheduler ()
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskEndScheduler\par \pard\plain 
{\tc\tcl2 \v vTaskEndScheduler}
{\xe \v vTaskEndScheduler}
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskEndScheduler( void )};\par}
Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler () was called, as if vTaskStartScheduler () had just returned.\par
See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().\par
vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.\par
vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.\par
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vTaskCode( void * pvParameters )
 \{
     for( ;; )
     \{
Task code goes here.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid At some point we want to end the real time kernel processing
so call ...
         vTaskEndScheduler ();
     \}
 \}\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  void vAFunction( void )
 \{
Create at least one task before starting the kernel.
     xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Start the real time kernel with preemption.
     vTaskStartScheduler ();\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Will only get here when the vTaskCode () task has called
vTaskEndScheduler ().  When we get here we are back to single task
execution.
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vTaskSuspendAll\par \pard\plain 
{\tc\tcl2 \v vTaskSuspendAll}
{\xe \v vTaskSuspendAll}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void {\b vTaskSuspendAll( void )};\par}
Suspends all real time kernel activity while keeping interrupts (including the kernel tick) enabled.\par
After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.\par
API functions that have the potential to cause a context switch (for example, {\b vTaskDelayUntil()}, {\b xQueueSend()}, etc.) must not be called while the scheduler is suspended.\par
Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vTask1( void * pvParameters )
 \{
     for( ;; )
     \{
Task code goes here.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid At some point the task wants to perform a long operation during
which it does not want to get swapped out.  It cannot use
taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
operation may cause interrupts to be missed - including the
ticks.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Prevent the real time kernel swapping out the task.
         vTaskSuspendAll ();\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Perform the operation here.  There is no need to use critical
sections as we have all the microcontroller processing time.
During this time interrupts will still operate and the kernel
tick count will be maintained.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid The operation is complete.  Restart the kernel.
         xTaskResumeAll ();
     \}
 \}
   \par}
 \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xTaskResumeAll\par \pard\plain 
{\tc\tcl2 \v xTaskResumeAll}
{\xe \v xTaskResumeAll}
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid char {\b xTaskResumeAll( void )};\par}
Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to vTaskSuspendAll () the kernel will take control of which task is executing at any time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.\par
}Example usage: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
 void vTask1( void * pvParameters )
 \{
     for( ;; )
     \{
Task code goes here.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid At some point the task wants to perform a long operation during
which it does not want to get swapped out.  It cannot use
taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
operation may cause interrupts to be missed - including the
ticks.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Prevent the real time kernel swapping out the task.
         vTaskSuspendAll ();\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Perform the operation here.  There is no need to use critical
sections as we have all the microcontroller processing time.
During this time interrupts will still operate and the real
time kernel tick count will be maintained.\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ...\par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid The operation is complete.  Restart the kernel.  We want to force
a context switch - but there is no point if resuming the scheduler
caused a context switch already.
         if( !xTaskResumeAll () )
         \{
              taskYIELD ();
         \}
     \}
 \}
   \par}
 \par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A_BLOCK_LINK Struct Reference\par \pard\plain 
{\tc\tcl2 \v A_BLOCK_LINK}
{\xe \v A_BLOCK_LINK}
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b A_BLOCK_LINK} * {\b pxNextFreeBlock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b xBlockSize}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pxNextFreeBlock\:A_BLOCK_LINK}
{\xe \v A_BLOCK_LINK\:pxNextFreeBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b A_BLOCK_LINK}* pxNextFreeBlock}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xBlockSize\:A_BLOCK_LINK}
{\xe \v A_BLOCK_LINK\:xBlockSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t xBlockSize}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b heap_2.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QueueDefinition Struct Reference\par \pard\plain 
{\tc\tcl2 \v QueueDefinition}
{\xe \v QueueDefinition}
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char * {\b pcHead}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char * {\b pcTail}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char * {\b pcWriteTo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char * {\b pcReadFrom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xList} {\b xTasksWaitingToSend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xList} {\b xTasksWaitingToReceive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned {\b portBASE_TYPE} {\b uxMessagesWaiting}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxLength}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxItemSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile signed {\b portBASE_TYPE} {\b xRxLock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile signed {\b portBASE_TYPE} {\b xTxLock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pcHead\:QueueDefinition}
{\xe \v QueueDefinition\:pcHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char* pcHead}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pcReadFrom\:QueueDefinition}
{\xe \v QueueDefinition\:pcReadFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char* pcReadFrom}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pcTail\:QueueDefinition}
{\xe \v QueueDefinition\:pcTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char* pcTail}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pcWriteTo\:QueueDefinition}
{\xe \v QueueDefinition\:pcWriteTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char* pcWriteTo}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxItemSize\:QueueDefinition}
{\xe \v QueueDefinition\:uxItemSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxItemSize}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxLength\:QueueDefinition}
{\xe \v QueueDefinition\:uxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxLength}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxMessagesWaiting\:QueueDefinition}
{\xe \v QueueDefinition\:uxMessagesWaiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned {\b portBASE_TYPE} uxMessagesWaiting}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xRxLock\:QueueDefinition}
{\xe \v QueueDefinition\:xRxLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile signed {\b portBASE_TYPE} xRxLock}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTasksWaitingToReceive\:QueueDefinition}
{\xe \v QueueDefinition\:xTasksWaitingToReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xList} xTasksWaitingToReceive}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTasksWaitingToSend\:QueueDefinition}
{\xe \v QueueDefinition\:xTasksWaitingToSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xList} xTasksWaitingToSend}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTxLock\:QueueDefinition}
{\xe \v QueueDefinition\:xTxLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile signed {\b portBASE_TYPE} xTxLock}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b queue.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tskTaskControlBlock Struct Reference\par \pard\plain 
{\tc\tcl2 \v tskTaskControlBlock}
{\xe \v tskTaskControlBlock}
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b portSTACK_TYPE} * {\b pxTopOfStack}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xListItem} {\b xGenericListItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xListItem} {\b xEventListItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxPriority}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portSTACK_TYPE} * {\b pxStack}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char {\b pcTaskName} [{\b configMAX_TASK_NAME_LEN}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pcTaskName\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:pcTaskName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char pcTaskName[{\b configMAX_TASK_NAME_LEN}]}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxStack\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:pxStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portSTACK_TYPE}* pxStack}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxTopOfStack\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:pxTopOfStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b portSTACK_TYPE}* pxTopOfStack}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxPriority\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:uxPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxPriority}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xEventListItem\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:xEventListItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xListItem} xEventListItem}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xGenericListItem\:tskTaskControlBlock}
{\xe \v tskTaskControlBlock\:xGenericListItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xListItem} xGenericListItem}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b tasks.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xLIST Struct Reference\par \pard\plain 
{\tc\tcl2 \v xLIST}
{\xe \v xLIST}
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
\par
{
{\f2 #include <list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile unsigned {\b portBASE_TYPE} {\b uxNumberOfItems}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b xListItem} * {\b pxIndex}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b xMiniListItem} {\b xListEnd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pxIndex\:xLIST}
{\xe \v xLIST\:pxIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b xListItem}* pxIndex}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxNumberOfItems\:xLIST}
{\xe \v xLIST\:uxNumberOfItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile unsigned {\b portBASE_TYPE} uxNumberOfItems}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xListEnd\:xLIST}
{\xe \v xLIST\:xListEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b xMiniListItem} xListEnd}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xLIST_ITEM Struct Reference\par \pard\plain 
{\tc\tcl2 \v xLIST_ITEM}
{\xe \v xLIST_ITEM}
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
\par
{
{\f2 #include <list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xItemValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST_ITEM} * {\b pxNext}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST_ITEM} * {\b pxPrevious}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvOwner}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvContainer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pvContainer\:xLIST_ITEM}
{\xe \v xLIST_ITEM\:pvContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvContainer}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pvOwner\:xLIST_ITEM}
{\xe \v xLIST_ITEM\:pvOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvOwner}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxNext\:xLIST_ITEM}
{\xe \v xLIST_ITEM\:pxNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b xLIST_ITEM}* pxNext}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxPrevious\:xLIST_ITEM}
{\xe \v xLIST_ITEM\:pxPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b xLIST_ITEM}* pxPrevious}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xItemValue\:xLIST_ITEM}
{\xe \v xLIST_ITEM\:xItemValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xItemValue}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xMEMORY_REGION Struct Reference\par \pard\plain 
{\tc\tcl2 \v xMEMORY_REGION}
{\xe \v xMEMORY_REGION}
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
\par
{
{\f2 #include <task.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvBaseAddress}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b ulLengthInBytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b ulParameters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pvBaseAddress\:xMEMORY_REGION}
{\xe \v xMEMORY_REGION\:pvBaseAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvBaseAddress}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ulLengthInBytes\:xMEMORY_REGION}
{\xe \v xMEMORY_REGION\:ulLengthInBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long ulLengthInBytes}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ulParameters\:xMEMORY_REGION}
{\xe \v xMEMORY_REGION\:ulParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long ulParameters}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b task.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xMINI_LIST_ITEM Struct Reference\par \pard\plain 
{\tc\tcl2 \v xMINI_LIST_ITEM}
{\xe \v xMINI_LIST_ITEM}
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
\par
{
{\f2 #include <list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xItemValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST_ITEM} * {\b pxNext}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST_ITEM} * {\b pxPrevious}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pxNext\:xMINI_LIST_ITEM}
{\xe \v xMINI_LIST_ITEM\:pxNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b xLIST_ITEM}* pxNext}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxPrevious\:xMINI_LIST_ITEM}
{\xe \v xMINI_LIST_ITEM\:pxPrevious}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b xLIST_ITEM}* pxPrevious}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xItemValue\:xMINI_LIST_ITEM}
{\xe \v xMINI_LIST_ITEM\:xItemValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xItemValue}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xTASK_PARAMTERS Struct Reference\par \pard\plain 
{\tc\tcl2 \v xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS}
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
\par
{
{\f2 #include <task.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pdTASK_CODE} {\b pvTaskCode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const signed char *const {\b pcName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b usStackDepth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvParameters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxPriority}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portSTACK_TYPE} * {\b puxStackBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xMemoryRegion} {\b xRegions} [{\b portNUM_CONFIGURABLE_REGIONS}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pcName\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:pcName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const signed char* const pcName}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v puxStackBuffer\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:puxStackBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portSTACK_TYPE}* puxStackBuffer}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pvParameters\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:pvParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvParameters}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pvTaskCode\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:pvTaskCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pdTASK_CODE} pvTaskCode}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v usStackDepth\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:usStackDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short usStackDepth}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxPriority\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:uxPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxPriority}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xRegions\:xTASK_PARAMTERS}
{\xe \v xTASK_PARAMTERS\:xRegions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xMemoryRegion} xRegions[{\b portNUM_CONFIGURABLE_REGIONS}]}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b task.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
xTIME_OUT Struct Reference\par \pard\plain 
{\tc\tcl2 \v xTIME_OUT}
{\xe \v xTIME_OUT}
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
\par
{
{\f2 #include <task.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xOverflowCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xTimeOnEntering}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v xOverflowCount\:xTIME_OUT}
{\xe \v xTIME_OUT\:xOverflowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xOverflowCount}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimeOnEntering\:xTIME_OUT}
{\xe \v xTIME_OUT\:xTimeOnEntering}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xTimeOnEntering}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/{\b task.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Autogenerated API include file for the Atmel Software Framework (ASF) }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <board.h>}\par
{\f2 #include <interrupt.h>}\par
{\f2 #include <parts.h>}\par
{\f2 #include <compiler.h>}\par
{\f2 #include <status_codes.h>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Autogenerated API include file for the Atmel Software Framework (ASF) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/boards/board.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/boards/board.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/boards/board.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard board header file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "compiler.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Base Boards\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EVK1100}\~ 1\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1100 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EVK1101}\~ 2\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EVK1101 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3C_EK}\~ 3\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3C UC3C_EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EVK1104}\~ 4\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A3 EVK1104 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EVK1105}\~ 5\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A EVK1105 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L0}\~ 6\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3L0 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L_EK}\~ 7\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3L-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XPLAIN}\~ 8\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC064X}\~ 10\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3 STK600 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC100X}\~ 11\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 STK600 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3_A3_XPLAINED}\~ 13\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3A3 UC3-A3 Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3_L0_XPLAINED}\~ 15\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3D}\~ 16\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3D board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3C0}\~ 17\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3C board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_B1_XPLAINED}\~ 18\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128B1 Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A1_XPLAINED}\~ 19\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega128A1 Xplain-A1 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L4}\~ 21\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL4 STK600 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3_L0_XPLAINED_BC}\~ 22\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUC3L0 UC3-L0 Xplained board controller board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA1284P_XPLAINED_BC}\~ 23\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P-Xplained board controller board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC044X}\~ 24\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC044X routing card board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3B0}\~ 25\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3B0 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3_L0_QT600}\~ 26\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 UC3L0 MCU board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A3BU_XPLAINED}\~ 27\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega256A3BU Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC064X_LCDX}\~ 28\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB3 STK600 RC064X LCDX board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC100X_LCDX}\~ 29\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
XMEGAB1 STK600 RC100X LCDX board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3B_BOARD_CONTROLLER}\~ 30\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B1 board controller for Atmel boards. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b RZ600}\~ 31\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3A RZ600 MCU board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S_EK}\~ 32\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3U_EK}\~ 33\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3U-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3X_EK}\~ 34\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3X-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3N_EK}\~ 35\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3N-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S_EK2}\~ 36\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM3S-EK2 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S_EK}\~ 37\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3A0}\~ 38\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 RCUC3A0 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_MEGA}\~ 39\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_1284P_XPLAINED}\~ 40\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega1284P Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S_XPLAINED}\~ 41\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b ATXMEGA128A1_QT600}\~ 42\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QT600 ATXMEGA128A1 MCU board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b ARDUINO_DUE_X}\~ 43\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arduino Due/X board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RCUC3L3}\~ 44\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATUCL3 STK600 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4L_EK}\~ 45\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4L-EK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_MEGA_RF}\~ 46\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 MEGA RF EVK board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_C3_XPLAINED}\~ 47\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATxmega384C3 Xplained board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b STK600_RC032X}\~ 48\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with RC032X routing card board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S_EK2}\~ 49\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAM4S-EK2 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SIMULATOR_XMEGA_A1}\~ 97\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simulator for XMEGA A1 devices. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b AVR_SIMULATOR_UC3}\~ 98\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AVR SIMULATOR for AVR UC3 device family. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b USER_BOARD}\~ 99\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User-reserved board (if any). }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b DUMMY_BOARD}\~ 100\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Extension Boards\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EXT1102}\~ 1\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3B EXT1102 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MC300}\~ 2\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT32UC3 MC300 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_1}\~ 3\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 1. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_2}\~ 4\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board 2. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_PRESSURE_1}\~ 5\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained pressure sensor board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_LIGHTPROX_1}\~ 6\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained light & proximity sensor board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_INERTIAL_A1}\~ 7\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained inertial sensor board "A". }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF231}\~ 8\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF230B}\~ 9\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b RZ600_AT86RF212}\~ 10\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AT86RF231 RF board in RZ600. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SENSORS_XPLAINED_BREADBOARD}\~ 11\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained sensor development breadboard. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SECURITY_XPLAINED}\~ 12\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Xplained ATSHA204 board. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b USER_EXT_BOARD}\~ 99\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b board_init} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function initializes the board target resources. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Standard board header file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file includes the appropriate board header file according to the defined board (parameter BOARD).\par
Copyright (c) 2009-2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8- and 32-bit AVR. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <parts.h>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8- and 32-bit AVR. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2010-2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt/interrupt_avr8.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt/interrupt_avr8.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/interrupt/interrupt_avr8.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8-bit AVR. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <compiler.h>}\par
{\f2 #include <parts.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Enable_global_interrupt}()\~ {\b cpu_irq_enable}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Disable_global_interrupt}()\~ {\b cpu_irq_disable}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Is_global_interrupt_enabled}()\~ {\b cpu_irq_is_enabled}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Global interrupt flags\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_enable}()\~ __enable_interrupt()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable interrupts globally. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_disable}()\~ __disable_interrupt()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable interrupts globally. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b cpu_irq_is_enabled}()\~ cpu_irq_is_enabled_flags(SREG)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if interrupts are globally enabled. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint8_t {\b irqflags_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type used for holding state of interrupt flag. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global interrupt management for 8-bit AVR. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (C) 2010-2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/parts.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/parts.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/common/utils/parts.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atmel part identification macros. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UC3}\~ ({\b UC3A} || {\b UC3B} || {\b UC3C} || {\b UC3D} || {\b UC3L})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XMEGA}\~ ({\b XMEGA_A} || {\b XMEGA_AU} || {\b XMEGA_B} || {\b XMEGA_C} || {\b XMEGA_D} || {\b XMEGA_E})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEGA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TINY}\~ ({\b TINY_UNCATEGORIZED})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAM}\~ ({\b SAM3S} || {\b SAM3U} || {\b SAM3N} || {\b SAM3XA} || {\b SAM4S} || {\b SAM4L})\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Convenience macros for part checking\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b AVR8_PART_IS_DEFINED}(part)\~ (defined(__ ## part ## __) || defined(__AVR_ ## part ## __))\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b AVR32_PART_IS_DEFINED}(part)\~ (defined(__AT32 ## part ## __) || defined(__AVR32_ ## part ## __))\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM_PART_IS_DEFINED}(part)\~ (defined(__ ## part ## __))\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 A series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3A0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3A1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3A3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3A4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 B series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3B0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3B1}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 C series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3C0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3C1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3C2}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 D series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3D3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3D4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 L series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L0128}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L0256}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L4}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L3_L4}\~ ({\b UC3L3} || {\b UC3L4})\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR UC3 families\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3A}\~ ({\b UC3A0} || {\b UC3A1} || {\b UC3A3} || {\b UC3A4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3B}\~ ({\b UC3B0} || {\b UC3B1})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3C}\~ ({\b UC3C0} || {\b UC3C1} || {\b UC3C2})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3D}\~ ({\b UC3D3} || {\b UC3D4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b UC3L}\~ ({\b UC3L0} || {\b UC3L0128} || {\b UC3L0256} || {\b UC3L3_L4})\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA A series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A3B}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA AU series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A1U}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A3U}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A3BU}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A4U}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA B series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_B1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_B3}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA C series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_C3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_C4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA D series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_D3}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_D4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA E series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_E5}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid AVR XMEGA families\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_A}\~ ({\b XMEGA_A1} || {\b XMEGA_A3} || {\b XMEGA_A3B} || {\b XMEGA_A4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_AU}\~ ({\b XMEGA_A1U} || {\b XMEGA_A3U} || {\b XMEGA_A3BU} || {\b XMEGA_A4U})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_B}\~ ({\b XMEGA_B1} || {\b XMEGA_B3})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_C}\~ ({\b XMEGA_C3} || {\b XMEGA_C4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_D}\~ ({\b XMEGA_D3} || {\b XMEGA_D4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b XMEGA_E}\~ ({\b XMEGA_E5})\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid ATmegaxx0/xx1 subgroups\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX1}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid megaAVR groups\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX0_1}\~ ({\b MEGA_XX0} || {\b MEGA_XX1})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX4}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX4_A}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX8}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX8_A}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX_A}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_RF}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid ATmegaxx_un0/un1/un2 subgroups\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN0}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_XX_UN2}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_UNCATEGORIZED}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MEGA_UNSPECIFIED}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid tinyAVR groups\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b TINY_UNCATEGORIZED}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM3S series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S2}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S4}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S8}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3SD8}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM3U series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3U1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3U2}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3U4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM3N series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3N1}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3N2}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3N4}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM3X series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3X4}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3X8}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM3A series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3A4}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3A8}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM4S series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S8}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S16}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4SA16}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4SD16}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4SD32}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM4L series\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4LS}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4LC}\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid SAM families\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3S}\~ ({\b SAM3S1} || {\b SAM3S2} || {\b SAM3S4} || {\b SAM3S8} || {\b SAM3SD8})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3U}\~ ({\b SAM3U1} || {\b SAM3U2} || {\b SAM3U4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3N}\~ ({\b SAM3N1} || {\b SAM3N2} || {\b SAM3N4})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM3XA}\~ ({\b SAM3X4} || {\b SAM3X8} || {\b SAM3A4} || {\b SAM3A8})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4S}\~ ({\b SAM4S8} || {\b SAM4S16} || {\b SAM4SA16} || {\b SAM4SD16} || {\b SAM4SD32})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SAM4L}\~ ({\b SAM4LS} || {\b SAM4LC})\par
}
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Atmel part identification macros. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (C) 2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/boards/stk600/rcx_x/init.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/boards/stk600/rcx_x/init.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/boards/stk600/rcx_x/init.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with MEGA routing board init. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <board.h>}\par
{\f2 #include <compiler.h>}\par
{\f2 #include <conf_board.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b board_init} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function initializes the board target resources. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STK600 with MEGA routing board init. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To use this board, define BOARD=STK600_MEGA.\par
Copyright (c) 2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer and utilities. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer and utilities. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2009-2012 Atmel Corporation. All rights reserved.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler/gas.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler/gas.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/assembler/gas.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer: GNU Assembler specifics. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PUBLIC_FUNCTION_SEGMENT}({\b name}, {\b segment})\~ gas_begin_func_segm {\b name} 1 {\b segment}\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Control Statements\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b REPEAT}(count)\~ .rept   count\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Repeat the following statements {\i count}  times. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b END_REPEAT}()\~ .endr\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the statements to be repeated. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b SET_LOC}(offset)\~ .org    offset\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the location counter to {\i offset} . }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b END_FILE}()\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the file. }{
}\par
}}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Data Objects\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b FILL_BYTES}(count)\~ .fill   count\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate space for {\i count}  bytes. }{
}\par
}}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Symbol Definition\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b L}({\b name})\~ .L##{\b name}\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turn {\i name}  into a local symbol, if possible. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b EXTERN_SYMBOL}({\b name})\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare {\i name}  as an external symbol referenced by this file. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b FUNCTION}({\b name})\~ gas_begin_func {\b name} 0\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a file-local function called {\i name} . }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b PUBLIC_FUNCTION}({\b name})\~ gas_begin_func {\b name} 1\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a globally visible function called {\i name} . }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b WEAK_FUNCTION}({\b name})\~ gas_weak_function {\b name}\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define a weak function called {\i name} . }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b WEAK_FUNCTION_ALIAS}({\b name}, strong_name)\~ gas_weak_function_alias {\b name} strong_name\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define {\i name}  as a weak alias for the function {\i strong_name} . }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b END_FUNC}({\b name})\~ .size   {\b name}, . - {\b name}\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark the end of the function called {\i name} . }{
}\par
}}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Section Definition\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b TEXT_SECTION}({\b name})\~ .section {\b name}, "ax", @progbits\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing executable code. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b RODATA_SECTION}({\b name})\~ .section {\b name}, "a", @progbits\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing read-only data. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b DATA_SECTION}({\b name})\~ .section {\b name}, "aw", @progbits\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable initialized data. }{
}\par
}}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b BSS_SECTION}({\b name})\~ .section {\b name}, "aw", @nobits\par
{
\pard\plain \s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new section containing writeable zero-initialized data. }{
}\par
}}
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro {\b ld_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro {\b reg}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro sym lda w sym endm macro \par
gas_begin_func {\b name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro sym lda w sym endm macro \par
gas_begin_func {\b is_public} if \par
{\b is_public} global {\b name} endif \par
section text {\b ax}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro sym lda w sym endm macro \par
gas_begin_func is_public if \par
is_public global {\b name} endif \par
section text progbits type \par
function {\b is_public}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
macro sym lda w sym endm macro \par
gas_begin_func {\b is_public} if \par
{\b is_public} global {\b name} endif \par
section text progbits type \par
function segment if {\b is_public} \par
global {\b name} endif section {\b segment}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assembler abstraction layer: GNU Assembler specifics. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2009-2012 Atmel Corporation. All rights reserved.\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab The name of Atmel may not be used to endorse or promote products derived from this software without specific prior written permission.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab This software may only be redistributed and used in connection with an Atmel microcontroller product.\par}
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PUBLIC_FUNCTION_SEGMENT\:gas.h}
{\xe \v gas.h\:PUBLIC_FUNCTION_SEGMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PUBLIC_FUNCTION_SEGMENT( {\b name},  {\b segment})\~ gas_begin_func_segm {\b name} 1 {\b segment}}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ax\:gas.h}
{\xe \v gas.h\:ax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro sym lda w sym endm macro gas_begin_func {\b is_public} if {\b is_public} global {\b name} endif section text progbits type function {\b segment} if {\b is_public} global {\b name} endif section ax}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_public\:gas.h}
{\xe \v gas.h\:is_public}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro sym lda w sym endm macro gas_begin_func is_public if is_public global {\b name} endif section text progbits type function is_public}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ld_addr\:gas.h}
{\xe \v gas.h\:ld_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro ld_addr}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:gas.h}
{\xe \v gas.h\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro sym lda w sym endm macro gas_begin_func {\b is_public} if {\b is_public} global name endif section text progbits type function {\b segment} if {\b is_public} global name endif section progbits type function strong_name global name weak name type function set name}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reg\:gas.h}
{\xe \v gas.h\:reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro sym lda w reg}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v segment\:gas.h}
{\xe \v gas.h\:segment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
macro sym lda w sym endm macro gas_begin_func {\b is_public} if {\b is_public} global {\b name} endif section text progbits type function segment if {\b is_public} global {\b name} endif section segment}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/compiler.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/compiler.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/compiler.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commonly used includes, types and macros. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <parts.h>}\par
{\f2 #include "interrupt.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNUSED}(v)\~ (void)(v)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marking {\i v}  as a unused parameter or value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b unused}(v)\~ do \{ (void)(v); \} while(0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marking {\i v}  as a unused parameter or value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b barrier}()\~ asm ("")\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory barrier. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Assert}(expr)\~ ((void) 0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This macro is used to test fatal errors. }{
}\par
}}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid MCU Endianism Handling\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b MSB}(u16)\~ (((uint8_t* )&u16)[1])\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
#define {\b LSB}(u16)\~ (((uint8_t* )&u16)[0])\par
}
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Commonly used includes, types and macros. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2011-2012 Atmel Corporation. All rights reserved.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v Assert\:compiler.h}
{\xe \v compiler.h\:Assert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Assert( expr)\~ ((void) 0)}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This macro is used to test fatal errors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The macro tests if the expression is false. If it is, a fatal error is detected and the application hangs up. If TEST_SUITE_DEFINE_ASSERT_MACRO is defined, a unit test version of the macro is used, to allow execution of further tests after a false expression.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i expr} \cell }{Expression to evaluate and supposed to be nonzero. \cell }
{\row }
}
}}
{\xe \v barrier\:compiler.h}
{\xe \v compiler.h\:barrier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define barrier()\~ asm ("")}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory barrier. }}\par
}
{\xe \v LSB\:compiler.h}
{\xe \v compiler.h\:LSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LSB( u16)\~ (((uint8_t* )&u16)[0])}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MSB\:compiler.h}
{\xe \v compiler.h\:MSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSB( u16)\~ (((uint8_t* )&u16)[1])}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UNUSED\:compiler.h}
{\xe \v compiler.h\:UNUSED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNUSED( v)\~ (void)(v)}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marking {\i v}  as a unused parameter or value. }}\par
}
{\xe \v unused\:compiler.h}
{\xe \v compiler.h\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define unused( v)\~ do \{ (void)(v); \} while(0)}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marking {\i v}  as a unused parameter or value. }}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/progmem.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/progmem.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/progmem.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program memory access. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program memory access. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2010-2012 Atmel Corporation. All rights reserved.\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab The name of Atmel may not be used to endorse or promote products derived from this software without specific prior written permission.\par}
{
\par
\pard\plain \s90\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab This software may only be redistributed and used in connection with an Atmel microcontroller product.\par}
THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/status_codes.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/status_codes.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/asf/mega/utils/status_codes.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Status code definitions. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b status_code} {\b status_code_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b status_code} \{ {\b STATUS_OK} = 0, 
{\b ERR_IO_ERROR} = -1, 
{\b ERR_FLUSHED} = -2, 
{\b ERR_TIMEOUT} = -3, 
{\b ERR_BAD_DATA} = -4, 
{\b ERR_PROTOCOL} = -5, 
{\b ERR_UNSUPPORTED_DEV} = -6, 
{\b ERR_NO_MEMORY} = -7, 
{\b ERR_INVALID_ARG} = -8, 
{\b ERR_BAD_ADDRESS} = -9, 
{\b ERR_BUSY} = -10, 
{\b ERR_BAD_FORMAT} = -11, 
{\b OPERATION_IN_PROGRESS} = -128
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Status code definitions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file defines various status codes returned by functions, indicating success or failure as well as what kind of failure.\par
Copyright (c) 2009-2012 Atmel Corporation. All rights reserved.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v status_code_t\:status_codes.h}
{\xe \v status_codes.h\:status_code_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b status_code} {\b status_code_t}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v status_code\:status_codes.h}
{\xe \v status_codes.h\:status_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b status_code}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Status code that may be returned by shell commands and protocol implementations.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Any change to these status codes and the corresponding message strings is strictly forbidden. New codes can be added, however, but make sure that any message string tables are updated at the same time. \par
}}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v STATUS_OK\:status_codes.h}
{\xe \v status_codes.h\:STATUS_OK}
{\b {\i STATUS_OK{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Success. \par
}{\xe \v ERR_IO_ERROR\:status_codes.h}
{\xe \v status_codes.h\:ERR_IO_ERROR}
{\b {\i ERR_IO_ERROR{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
I/O error. \par
}{\xe \v ERR_FLUSHED\:status_codes.h}
{\xe \v status_codes.h\:ERR_FLUSHED}
{\b {\i ERR_FLUSHED{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Request flushed from queue. \par
}{\xe \v ERR_TIMEOUT\:status_codes.h}
{\xe \v status_codes.h\:ERR_TIMEOUT}
{\b {\i ERR_TIMEOUT{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operation timed out. \par
}{\xe \v ERR_BAD_DATA\:status_codes.h}
{\xe \v status_codes.h\:ERR_BAD_DATA}
{\b {\i ERR_BAD_DATA{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data integrity check failed. \par
}{\xe \v ERR_PROTOCOL\:status_codes.h}
{\xe \v status_codes.h\:ERR_PROTOCOL}
{\b {\i ERR_PROTOCOL{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Protocol error. \par
}{\xe \v ERR_UNSUPPORTED_DEV\:status_codes.h}
{\xe \v status_codes.h\:ERR_UNSUPPORTED_DEV}
{\b {\i ERR_UNSUPPORTED_DEV{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unsupported device. \par
}{\xe \v ERR_NO_MEMORY\:status_codes.h}
{\xe \v status_codes.h\:ERR_NO_MEMORY}
{\b {\i ERR_NO_MEMORY{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Insufficient memory. \par
}{\xe \v ERR_INVALID_ARG\:status_codes.h}
{\xe \v status_codes.h\:ERR_INVALID_ARG}
{\b {\i ERR_INVALID_ARG{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalid argument. \par
}{\xe \v ERR_BAD_ADDRESS\:status_codes.h}
{\xe \v status_codes.h\:ERR_BAD_ADDRESS}
{\b {\i ERR_BAD_ADDRESS{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bad address. \par
}{\xe \v ERR_BUSY\:status_codes.h}
{\xe \v status_codes.h\:ERR_BUSY}
{\b {\i ERR_BUSY{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resource is busy. \par
}{\xe \v ERR_BAD_FORMAT\:status_codes.h}
{\xe \v status_codes.h\:ERR_BAD_FORMAT}
{\b {\i ERR_BAD_FORMAT{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data format not recognized. \par
}{\xe \v OPERATION_IN_PROGRESS\:status_codes.h}
{\xe \v status_codes.h\:OPERATION_IN_PROGRESS}
{\b {\i OPERATION_IN_PROGRESS{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
}}  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operation in progress. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This status code is for driver-internal use when an operation is currently being performed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Drivers should never return this status code to any callers. It is strictly for internal use. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/config/conf_board.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/config/conf_board.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/config/conf_board.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega2560 on STK600 board configuration template. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ATmega2560 on STK600 board configuration template. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOS.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOS.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOS.h}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include "projdefs.h"}\par
{\f2 #include "FreeRTOSConfig.h"}\par
{\f2 #include "portable.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xTaskGetIdleTaskHandle}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xTimerGetTimerDaemonTaskHandle}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xQueueGetMutexHolder}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_pcTaskGetTaskName}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_APPLICATION_TASK_TAG}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_uxTaskGetStackHighWaterMark}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_RECURSIVE_MUTEXES}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_MUTEXES}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_TIMERS}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_COUNTING_SEMAPHORES}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_ALTERNATIVE_API}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCRITICAL_NESTING_IN_TCB}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xTaskResumeFromISR}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configASSERT}(x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portALIGNMENT_ASSERT_pxCurrentTCB}\~ {\b configASSERT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xTaskGetSchedulerState}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_xTaskGetCurrentTaskHandle}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSET_INTERRUPT_MASK_FROM_ISR}()\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCLEAR_INTERRUPT_MASK_FROM_ISR}(uxSavedStatusValue)\~ ( void ) uxSavedStatusValue\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCLEAN_UP_TCB}(pxTCB)\~ ( void ) pxTCB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSETUP_TCB}(pxTCB)\~ ( void ) pxTCB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vQueueAddToRegistry}(xQueue, pcName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vQueueUnregisterQueue}(xQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portPOINTER_SIZE_TYPE}\~ unsigned long\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceSTART}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceEND}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_SWITCHED_IN}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_SWITCHED_OUT}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_PRIORITY_INHERIT}(pxTCBOfMutexHolder, uxInheritedPriority)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_PRIORITY_DISINHERIT}(pxTCBOfMutexHolder, uxOriginalPriority)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceBLOCKING_ON_QUEUE_RECEIVE}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceBLOCKING_ON_QUEUE_SEND}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configCHECK_FOR_STACK_OVERFLOW}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceMOVED_TASK_TO_READY_STATE}(pxTCB)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_CREATE}(pxNewQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_CREATE_FAILED}(ucQueueType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceCREATE_MUTEX}(pxNewQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceCREATE_MUTEX_FAILED}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceGIVE_MUTEX_RECURSIVE}(pxMutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceGIVE_MUTEX_RECURSIVE_FAILED}(pxMutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTAKE_MUTEX_RECURSIVE}(pxMutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTAKE_MUTEX_RECURSIVE_FAILED}(pxMutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceCREATE_COUNTING_SEMAPHORE}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceCREATE_COUNTING_SEMAPHORE_FAILED}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_SEND}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_SEND_FAILED}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_RECEIVE}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_PEEK}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_RECEIVE_FAILED}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_SEND_FROM_ISR}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_SEND_FROM_ISR_FAILED}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_RECEIVE_FROM_ISR}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_RECEIVE_FROM_ISR_FAILED}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceQUEUE_DELETE}(pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_CREATE}(pxNewTCB)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_CREATE_FAILED}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_DELETE}(pxTaskToDelete)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_DELAY_UNTIL}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_DELAY}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_PRIORITY_SET}(pxTask, uxNewPriority)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_SUSPEND}(pxTaskToSuspend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_RESUME}(pxTaskToResume)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_RESUME_FROM_ISR}(pxTaskToResume)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTASK_INCREMENT_TICK}(xTickCount)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTIMER_CREATE}(pxNewTimer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTIMER_CREATE_FAILED}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTIMER_COMMAND_SEND}(xTimer, xMessageID, xMessageValueValue, xReturn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTIMER_EXPIRED}(pxTimer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b traceTIMER_COMMAND_RECEIVED}(pxTimer, xMessageID, xMessageValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configGENERATE_RUN_TIME_STATS}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCONFIGURE_TIMER_FOR_RUN_TIME_STATS}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_MALLOC_FAILED_HOOK}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portPRIVILEGE_BIT}\~ ( ( unsigned {\b portBASE_TYPE} ) 0x00 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portYIELD_WITHIN_API}\~ {\b portYIELD}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pvPortMallocAligned}(x, puxStackBuffer)\~ ( ( ( puxStackBuffer ) == NULL ) ? ( {\b pvPortMalloc}( ( x ) ) ) : ( puxStackBuffer ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vPortFreeAligned}(pvBlockToFree)\~ {\b vPortFree}( pvBlockToFree )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b portBASE_TYPE}(* {\b pdTASK_HOOK_CODE} )(void *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v configASSERT\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configASSERT( x)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configCHECK_FOR_STACK_OVERFLOW\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configCHECK_FOR_STACK_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configCHECK_FOR_STACK_OVERFLOW\~ 0}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configGENERATE_RUN_TIME_STATS\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configGENERATE_RUN_TIME_STATS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configGENERATE_RUN_TIME_STATS\~ 0}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_ALTERNATIVE_API\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_ALTERNATIVE_API}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_ALTERNATIVE_API\~ 0}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_APPLICATION_TASK_TAG\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_APPLICATION_TASK_TAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_APPLICATION_TASK_TAG\~ 0}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_COUNTING_SEMAPHORES\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_COUNTING_SEMAPHORES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_COUNTING_SEMAPHORES\~ 0}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_MALLOC_FAILED_HOOK\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_MALLOC_FAILED_HOOK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_MALLOC_FAILED_HOOK\~ 0}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_MUTEXES\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_MUTEXES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_MUTEXES\~ 0}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_RECURSIVE_MUTEXES\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_RECURSIVE_MUTEXES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_RECURSIVE_MUTEXES\~ 0}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_TIMERS\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:configUSE_TIMERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_TIMERS\~ 0}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_pcTaskGetTaskName\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_pcTaskGetTaskName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_pcTaskGetTaskName\~ 0}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_uxTaskGetStackHighWaterMark\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_uxTaskGetStackHighWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_uxTaskGetStackHighWaterMark\~ 0}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xQueueGetMutexHolder\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xQueueGetMutexHolder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xQueueGetMutexHolder\~ 0}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xTaskGetCurrentTaskHandle\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xTaskGetCurrentTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xTaskGetCurrentTaskHandle\~ 0}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xTaskGetIdleTaskHandle\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xTaskGetIdleTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xTaskGetIdleTaskHandle\~ 0}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xTaskGetSchedulerState\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xTaskGetSchedulerState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xTaskGetSchedulerState\~ 0}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xTaskResumeFromISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xTaskResumeFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xTaskResumeFromISR\~ 1}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_xTimerGetTimerDaemonTaskHandle\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:INCLUDE_xTimerGetTimerDaemonTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_xTimerGetTimerDaemonTaskHandle\~ 0}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portALIGNMENT_ASSERT_pxCurrentTCB\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portALIGNMENT_ASSERT_pxCurrentTCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portALIGNMENT_ASSERT_pxCurrentTCB\~ {\b configASSERT}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCLEAN_UP_TCB\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portCLEAN_UP_TCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCLEAN_UP_TCB( pxTCB)\~ ( void ) pxTCB}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCLEAR_INTERRUPT_MASK_FROM_ISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portCLEAR_INTERRUPT_MASK_FROM_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue)\~ ( void ) uxSavedStatusValue}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCONFIGURE_TIMER_FOR_RUN_TIME_STATS\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portCONFIGURE_TIMER_FOR_RUN_TIME_STATS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCRITICAL_NESTING_IN_TCB\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portCRITICAL_NESTING_IN_TCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCRITICAL_NESTING_IN_TCB\~ 0}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portPOINTER_SIZE_TYPE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portPOINTER_SIZE_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portPOINTER_SIZE_TYPE\~ unsigned long}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portPRIVILEGE_BIT\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portPRIVILEGE_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portPRIVILEGE_BIT\~ ( ( unsigned {\b portBASE_TYPE} ) 0x00 )}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSET_INTERRUPT_MASK_FROM_ISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portSET_INTERRUPT_MASK_FROM_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSET_INTERRUPT_MASK_FROM_ISR()\~ 0}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSETUP_TCB\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portSETUP_TCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSETUP_TCB( pxTCB)\~ ( void ) pxTCB}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portYIELD_WITHIN_API\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:portYIELD_WITHIN_API}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portYIELD_WITHIN_API\~ {\b portYIELD}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pvPortMallocAligned\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:pvPortMallocAligned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pvPortMallocAligned( x,  puxStackBuffer)\~ ( ( ( puxStackBuffer ) == NULL ) ? ( {\b pvPortMalloc}( ( x ) ) ) : ( puxStackBuffer ) )}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceBLOCKING_ON_QUEUE_RECEIVE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceBLOCKING_ON_QUEUE_RECEIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceBLOCKING_ON_QUEUE_SEND\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceBLOCKING_ON_QUEUE_SEND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceBLOCKING_ON_QUEUE_SEND( pxQueue)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceCREATE_COUNTING_SEMAPHORE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceCREATE_COUNTING_SEMAPHORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceCREATE_COUNTING_SEMAPHORE()}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceCREATE_COUNTING_SEMAPHORE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceCREATE_COUNTING_SEMAPHORE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceCREATE_COUNTING_SEMAPHORE_FAILED()}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceCREATE_MUTEX\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceCREATE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceCREATE_MUTEX( pxNewQueue)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceCREATE_MUTEX_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceCREATE_MUTEX_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceCREATE_MUTEX_FAILED()}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceEND\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceEND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceEND()}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceGIVE_MUTEX_RECURSIVE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceGIVE_MUTEX_RECURSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceGIVE_MUTEX_RECURSIVE( pxMutex)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceGIVE_MUTEX_RECURSIVE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceGIVE_MUTEX_RECURSIVE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceMOVED_TASK_TO_READY_STATE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceMOVED_TASK_TO_READY_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceMOVED_TASK_TO_READY_STATE( pxTCB)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_CREATE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_CREATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_CREATE( pxNewQueue)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_CREATE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_CREATE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_CREATE_FAILED( ucQueueType)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_DELETE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_DELETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_DELETE( pxQueue)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_PEEK\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_PEEK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_PEEK( pxQueue)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_RECEIVE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_RECEIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_RECEIVE( pxQueue)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_RECEIVE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_RECEIVE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_RECEIVE_FAILED( pxQueue)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_RECEIVE_FROM_ISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_RECEIVE_FROM_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_RECEIVE_FROM_ISR_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_RECEIVE_FROM_ISR_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_SEND\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_SEND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_SEND( pxQueue)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_SEND_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_SEND_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_SEND_FAILED( pxQueue)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_SEND_FROM_ISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_SEND_FROM_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_SEND_FROM_ISR( pxQueue)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceQUEUE_SEND_FROM_ISR_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceQUEUE_SEND_FROM_ISR_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceSTART\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceSTART}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceSTART()}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTAKE_MUTEX_RECURSIVE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTAKE_MUTEX_RECURSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTAKE_MUTEX_RECURSIVE( pxMutex)}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTAKE_MUTEX_RECURSIVE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTAKE_MUTEX_RECURSIVE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_CREATE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_CREATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_CREATE( pxNewTCB)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_CREATE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_CREATE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_CREATE_FAILED()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_DELAY\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_DELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_DELAY()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_DELAY_UNTIL\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_DELAY_UNTIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_DELAY_UNTIL()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_DELETE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_DELETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_DELETE( pxTaskToDelete)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_INCREMENT_TICK\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_INCREMENT_TICK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_INCREMENT_TICK( xTickCount)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_PRIORITY_DISINHERIT\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_PRIORITY_DISINHERIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder,  uxOriginalPriority)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_PRIORITY_INHERIT\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_PRIORITY_INHERIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder,  uxInheritedPriority)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_PRIORITY_SET\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_PRIORITY_SET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_PRIORITY_SET( pxTask,  uxNewPriority)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_RESUME\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_RESUME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_RESUME( pxTaskToResume)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_RESUME_FROM_ISR\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_RESUME_FROM_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_RESUME_FROM_ISR( pxTaskToResume)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_SUSPEND\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_SUSPEND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_SUSPEND( pxTaskToSuspend)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_SWITCHED_IN\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_SWITCHED_IN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_SWITCHED_IN()}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTASK_SWITCHED_OUT\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTASK_SWITCHED_OUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTASK_SWITCHED_OUT()}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTIMER_COMMAND_RECEIVED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTIMER_COMMAND_RECEIVED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTIMER_COMMAND_RECEIVED( pxTimer,  xMessageID,  xMessageValue)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTIMER_COMMAND_SEND\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTIMER_COMMAND_SEND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTIMER_COMMAND_SEND( xTimer,  xMessageID,  xMessageValueValue,  xReturn)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTIMER_CREATE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTIMER_CREATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTIMER_CREATE( pxNewTimer)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTIMER_CREATE_FAILED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTIMER_CREATE_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTIMER_CREATE_FAILED()}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v traceTIMER_EXPIRED\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:traceTIMER_EXPIRED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define traceTIMER_EXPIRED( pxTimer)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortFreeAligned\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:vPortFreeAligned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vPortFreeAligned( pvBlockToFree)\~ {\b vPortFree}( pvBlockToFree )}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueAddToRegistry\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:vQueueAddToRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vQueueAddToRegistry( xQueue,  pcName)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueUnregisterQueue\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:vQueueUnregisterQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vQueueUnregisterQueue( xQueue)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v pdTASK_HOOK_CODE\:FreeRTOS.h}
{\xe \v FreeRTOS.h\:pdTASK_HOOK_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b portBASE_TYPE}(* pdTASK_HOOK_CODE)(void *)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOSConfig.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOSConfig.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/FreeRTOSConfig.h}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <avr/io.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_PREEMPTION}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_IDLE_HOOK}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_TICK_HOOK}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configCPU_CLOCK_HZ}\~ ( ( unsigned long ) 8000000 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configTICK_RATE_HZ}\~ ( ( {\b portTickType} ) 1000 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configMAX_PRIORITIES}\~ ( ( unsigned {\b portBASE_TYPE} ) 6 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configMINIMAL_STACK_SIZE}\~ ( ( unsigned short ) 85 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configTOTAL_HEAP_SIZE}\~ ( (size_t ) ( 5000 ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configMAX_TASK_NAME_LEN}\~ ( 20 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_TRACE_FACILITY}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_16_BIT_TICKS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configIDLE_SHOULD_YIELD}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configQUEUE_REGISTRY_SIZE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configUSE_CO_ROUTINES}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b configMAX_CO_ROUTINE_PRIORITIES}\~ ( 2 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskPrioritySet}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_uxTaskPriorityGet}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskDelete}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskCleanUpResources}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskSuspend}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskDelayUntil}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_vTaskDelay}\~ 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v configCPU_CLOCK_HZ\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configCPU_CLOCK_HZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configCPU_CLOCK_HZ\~ ( ( unsigned long ) 8000000 )}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configIDLE_SHOULD_YIELD\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configIDLE_SHOULD_YIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configIDLE_SHOULD_YIELD\~ 1}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configMAX_CO_ROUTINE_PRIORITIES\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configMAX_CO_ROUTINE_PRIORITIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configMAX_CO_ROUTINE_PRIORITIES\~ ( 2 )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configMAX_PRIORITIES\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configMAX_PRIORITIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configMAX_PRIORITIES\~ ( ( unsigned {\b portBASE_TYPE} ) 6 )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configMAX_TASK_NAME_LEN\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configMAX_TASK_NAME_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configMAX_TASK_NAME_LEN\~ ( 20 )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configMINIMAL_STACK_SIZE\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configMINIMAL_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configMINIMAL_STACK_SIZE\~ ( ( unsigned short ) 85 )}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configQUEUE_REGISTRY_SIZE\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configQUEUE_REGISTRY_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configQUEUE_REGISTRY_SIZE\~ 0}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configTICK_RATE_HZ\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configTICK_RATE_HZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configTICK_RATE_HZ\~ ( ( {\b portTickType} ) 1000 )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configTOTAL_HEAP_SIZE\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configTOTAL_HEAP_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configTOTAL_HEAP_SIZE\~ ( (size_t ) ( 5000 ) )}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_16_BIT_TICKS\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_16_BIT_TICKS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_16_BIT_TICKS\~ 1}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_CO_ROUTINES\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_CO_ROUTINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_CO_ROUTINES\~ 0}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_IDLE_HOOK\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_IDLE_HOOK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_IDLE_HOOK\~ 0}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_PREEMPTION\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_PREEMPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_PREEMPTION\~ 1}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_TICK_HOOK\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_TICK_HOOK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_TICK_HOOK\~ 0}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v configUSE_TRACE_FACILITY\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:configUSE_TRACE_FACILITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define configUSE_TRACE_FACILITY\~ 0}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_uxTaskPriorityGet\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_uxTaskPriorityGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_uxTaskPriorityGet\~ 0}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskCleanUpResources\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskCleanUpResources}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskCleanUpResources\~ 0}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskDelay\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskDelay\~ 1}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskDelayUntil\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskDelayUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskDelayUntil\~ 1}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskDelete\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskDelete\~ 1}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskPrioritySet\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskPrioritySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskPrioritySet\~ 1}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INCLUDE_vTaskSuspend\:FreeRTOSConfig.h}
{\xe \v FreeRTOSConfig.h\:INCLUDE_vTaskSuspend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_vTaskSuspend\~ 1}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/heap_2.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/heap_2.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/heap_2.c}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b xRTOS_HEAP}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b A_BLOCK_LINK}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MPU_WRAPPERS_INCLUDED_FROM_API_FILE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b heapMINIMUM_BLOCK_SIZE}\~ ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvInsertBlockIntoFreeList}(pxBlockToInsert)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvHeapInit}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b A_BLOCK_LINK} {\b xBlockLink}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvPortMalloc} (size_t xWantedSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortFree} (void *pv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b xPortGetFreeHeapSize} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortInitialiseBlocks} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v heapMINIMUM_BLOCK_SIZE\:heap_2.c}
{\xe \v heap_2.c\:heapMINIMUM_BLOCK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define heapMINIMUM_BLOCK_SIZE\~ ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MPU_WRAPPERS_INCLUDED_FROM_API_FILE\:heap_2.c}
{\xe \v heap_2.c\:MPU_WRAPPERS_INCLUDED_FROM_API_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prvHeapInit\:heap_2.c}
{\xe \v heap_2.c\:prvHeapInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvHeapInit()}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{                                                                                   \\\par
xBlockLink *pxFirstFreeBlock;                                                       \\\par
                                                                                    \\\par
    /* xStart is used to hold a pointer to the first item in the list of free */    \\\par
    /* blocks.  The void cast is used to prevent compiler warnings. */              \\\par
    xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;                               \\\par
    xStart.xBlockSize = ( size_t ) 0;                                               \\\par
                                                                                    \\\par
    /* xEnd is used to mark the end of the list of free blocks. */                  \\\par
    xEnd.xBlockSize = configTOTAL_HEAP_SIZE;                                        \\\par
    xEnd.pxNextFreeBlock = NULL;                                                    \\\par
                                                                                    \\\par
    /* To start with there is a single free block that is sized to take up the      \\\par
    entire heap space. */                                                           \\\par
    pxFirstFreeBlock = ( void * ) xHeap.ucHeap;                                     \\\par
    pxFirstFreeBlock->xBlockSize = configTOTAL_HEAP_SIZE;                           \\\par
    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;                                      \\\par
\}\par
}
}
{\xe \v prvInsertBlockIntoFreeList\:heap_2.c}
{\xe \v heap_2.c\:prvInsertBlockIntoFreeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvInsertBlockIntoFreeList( pxBlockToInsert)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{                                                                                   \\\par
xBlockLink *pxIterator;                                                             \\\par
size_t xBlockSize;                                                                  \\\par
                                                                                    \\\par
    xBlockSize = pxBlockToInsert->xBlockSize;                                       \\\par
                                                                                    \\\par
    /* Iterate through the list until a block is found that has a larger size */    \\\par
    /* than the block we are inserting. */                                          \\\par
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock ) \\\par
    \{                                                                               \\\par
        /* There is nothing to do here - just iterate to the correct position. */   \\\par
    \}                                                                               \\\par
                                                                                    \\\par
    /* Update the list to include the block being inserted in the correct */        \\\par
    /* position. */                                                                 \\\par
    pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;                 \\\par
    pxIterator->pxNextFreeBlock = pxBlockToInsert;                                  \\\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v xBlockLink\:heap_2.c}
{\xe \v heap_2.c\:xBlockLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b A_BLOCK_LINK}  {\b xBlockLink}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pvPortMalloc\:heap_2.c}
{\xe \v heap_2.c\:pvPortMalloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvPortMalloc (size_t {\i xWantedSize})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortFree\:heap_2.c}
{\xe \v heap_2.c\:vPortFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortFree (void * {\i pv})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortInitialiseBlocks\:heap_2.c}
{\xe \v heap_2.c\:vPortInitialiseBlocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortInitialiseBlocks (void )}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xPortGetFreeHeapSize\:heap_2.c}
{\xe \v heap_2.c\:xPortGetFreeHeapSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t xPortGetFreeHeapSize (void )}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.c}
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "list.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInitialise} ({\b xList} *pxList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInitialiseItem} ({\b xListItem} *pxItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInsertEnd} ({\b xList} *pxList, {\b xListItem} *pxNewListItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInsert} ({\b xList} *pxList, {\b xListItem} *pxNewListItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListRemove} ({\b xListItem} *pxItemToRemove)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vListInitialise\:list.c}
{\xe \v list.c\:vListInitialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInitialise ({\b xList} * {\i pxList})}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInitialiseItem\:list.c}
{\xe \v list.c\:vListInitialiseItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInitialiseItem ({\b xListItem} * {\i pxItem})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInsert\:list.c}
{\xe \v list.c\:vListInsert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInsert ({\b xList} * {\i pxList}, {\b xListItem} * {\i pxNewListItem})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInsertEnd\:list.c}
{\xe \v list.c\:vListInsertEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInsertEnd ({\b xList} * {\i pxList}, {\b xListItem} * {\i pxNewListItem})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListRemove\:list.c}
{\xe \v list.c\:vListRemove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListRemove ({\b xListItem} * {\i pxItemToRemove})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/list.h}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST_ITEM}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xMINI_LIST_ITEM}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xLIST}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listSET_LIST_ITEM_OWNER}(pxListItem, pxOwner)\~ ( pxListItem )->pvOwner = ( void * ) ( pxOwner )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listGET_LIST_ITEM_OWNER}(pxListItem)\~ ( pxListItem )->pvOwner\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listSET_LIST_ITEM_VALUE}(pxListItem, xValue)\~ ( pxListItem )->xItemValue = ( xValue )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listGET_LIST_ITEM_VALUE}(pxListItem)\~ ( ( pxListItem )->xItemValue )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listGET_ITEM_VALUE_OF_HEAD_ENTRY}(pxList)\~ ( (&( ( pxList )->xListEnd ))->pxNext->xItemValue )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listLIST_IS_EMPTY}(pxList)\~ ( ( pxList )->uxNumberOfItems == ( unsigned {\b portBASE_TYPE} ) 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listCURRENT_LIST_LENGTH}(pxList)\~ ( ( pxList )->uxNumberOfItems )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listGET_OWNER_OF_NEXT_ENTRY}(pxTCB, pxList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listGET_OWNER_OF_HEAD_ENTRY}(pxList)\~ ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listIS_CONTAINED_WITHIN}(pxList, pxListItem)\~ ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b listLIST_IS_INITIALISED}(pxList)\~ ( ( pxList )->xListEnd.xItemValue == {\b portMAX_DELAY} )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xLIST_ITEM} {\b xListItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xMINI_LIST_ITEM} {\b xMiniListItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xLIST} {\b xList}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInitialise} ({\b xList} *pxList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInitialiseItem} ({\b xListItem} *pxItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInsert} ({\b xList} *pxList, {\b xListItem} *pxNewListItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListInsertEnd} ({\b xList} *pxList, {\b xListItem} *pxNewListItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vListRemove} ({\b xListItem} *pxItemToRemove)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v listCURRENT_LIST_LENGTH\:list.h}
{\xe \v list.h\:listCURRENT_LIST_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listCURRENT_LIST_LENGTH( pxList)\~ ( ( pxList )->uxNumberOfItems )}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listGET_ITEM_VALUE_OF_HEAD_ENTRY\:list.h}
{\xe \v list.h\:listGET_ITEM_VALUE_OF_HEAD_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList)\~ ( (&( ( pxList )->xListEnd ))->pxNext->xItemValue )}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listGET_LIST_ITEM_OWNER\:list.h}
{\xe \v list.h\:listGET_LIST_ITEM_OWNER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listGET_LIST_ITEM_OWNER( pxListItem)\~ ( pxListItem )->pvOwner}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listGET_LIST_ITEM_VALUE\:list.h}
{\xe \v list.h\:listGET_LIST_ITEM_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listGET_LIST_ITEM_VALUE( pxListItem)\~ ( ( pxListItem )->xItemValue )}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listGET_OWNER_OF_HEAD_ENTRY\:list.h}
{\xe \v list.h\:listGET_OWNER_OF_HEAD_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listGET_OWNER_OF_HEAD_ENTRY( pxList)\~ ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listGET_OWNER_OF_NEXT_ENTRY\:list.h}
{\xe \v list.h\:listGET_OWNER_OF_NEXT_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB,  pxList)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{                                                                                       \\\par
xList * const pxConstList = ( pxList );                                                 \\\par
    /* Increment the index to the next item and return the item, ensuring */            \\\par
    /* we don't return the marker used at the end of the list.  */                      \\\par
    ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;                        \\\par
    if( ( pxConstList )->pxIndex == ( xListItem * ) &( ( pxConstList )->xListEnd ) )    \\\par
    \{                                                                                   \\\par
        ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;                    \\\par
    \}                                                                                   \\\par
    ( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;                                      \\\par
\}\par
}
}
{\xe \v listIS_CONTAINED_WITHIN\:list.h}
{\xe \v list.h\:listIS_CONTAINED_WITHIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listIS_CONTAINED_WITHIN( pxList,  pxListItem)\~ ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) )}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listLIST_IS_EMPTY\:list.h}
{\xe \v list.h\:listLIST_IS_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listLIST_IS_EMPTY( pxList)\~ ( ( pxList )->uxNumberOfItems == ( unsigned {\b portBASE_TYPE} ) 0 )}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listLIST_IS_INITIALISED\:list.h}
{\xe \v list.h\:listLIST_IS_INITIALISED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listLIST_IS_INITIALISED( pxList)\~ ( ( pxList )->xListEnd.xItemValue == {\b portMAX_DELAY} )}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listSET_LIST_ITEM_OWNER\:list.h}
{\xe \v list.h\:listSET_LIST_ITEM_OWNER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listSET_LIST_ITEM_OWNER( pxListItem,  pxOwner)\~ ( pxListItem )->pvOwner = ( void * ) ( pxOwner )}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listSET_LIST_ITEM_VALUE\:list.h}
{\xe \v list.h\:listSET_LIST_ITEM_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define listSET_LIST_ITEM_VALUE( pxListItem,  xValue)\~ ( pxListItem )->xItemValue = ( xValue )}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v xList\:list.h}
{\xe \v list.h\:xList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xLIST}  {\b xList}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xListItem\:list.h}
{\xe \v list.h\:xListItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xLIST_ITEM} {\b xListItem}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xMiniListItem\:list.h}
{\xe \v list.h\:xMiniListItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xMINI_LIST_ITEM} {\b xMiniListItem}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vListInitialise\:list.h}
{\xe \v list.h\:vListInitialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInitialise ({\b xList} * {\i pxList})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInitialiseItem\:list.h}
{\xe \v list.h\:vListInitialiseItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInitialiseItem ({\b xListItem} * {\i pxItem})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInsert\:list.h}
{\xe \v list.h\:vListInsert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInsert ({\b xList} * {\i pxList}, {\b xListItem} * {\i pxNewListItem})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListInsertEnd\:list.h}
{\xe \v list.h\:vListInsertEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListInsertEnd ({\b xList} * {\i pxList}, {\b xListItem} * {\i pxNewListItem})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vListRemove\:list.h}
{\xe \v list.h\:vListRemove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vListRemove ({\b xListItem} * {\i pxItemToRemove})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/main.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/main.c}
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <asf.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
{\f2 #include "partest.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b led_testLED_TASK_PRIORITY}\~ ( {\b tskIDLE_PRIORITY} + 1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b led_test500_MILLISECOND_TOGGLE}\~ ( 4 )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vFlashLed500ms} (void *blinktime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vStartBlink} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v led_test500_MILLISECOND_TOGGLE\:main.c}
{\xe \v main.c\:led_test500_MILLISECOND_TOGGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define led_test500_MILLISECOND_TOGGLE\~ ( 4 )}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v led_testLED_TASK_PRIORITY\:main.c}
{\xe \v main.c\:led_testLED_TASK_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define led_testLED_TASK_PRIORITY\~ ( {\b tskIDLE_PRIORITY} + 1 )}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vFlashLed500ms\:main.c}
{\xe \v main.c\:vFlashLed500ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vFlashLed500ms (void * {\i blinktime})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vStartBlink\:main.c}
{\xe \v main.c\:vStartBlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vStartBlink (void )}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/mpu_wrappers.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/mpu_wrappers.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/mpu_wrappers.h}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRIVILEGED_DATA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portUSING_MPU_WRAPPERS}\~ 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v portUSING_MPU_WRAPPERS\:mpu_wrappers.h}
{\xe \v mpu_wrappers.h\:portUSING_MPU_WRAPPERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portUSING_MPU_WRAPPERS\~ 0}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PRIVILEGED_DATA\:mpu_wrappers.h}
{\xe \v mpu_wrappers.h\:PRIVILEGED_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRIVILEGED_DATA}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PRIVILEGED_FUNCTION\:mpu_wrappers.h}
{\xe \v mpu_wrappers.h\:PRIVILEGED_FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRIVILEGED_FUNCTION}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/partest.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/partest.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/partest.h}
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b partstDEFAULT_PORT_ADDRESS}\~ ( ( unsigned short ) 0x378 )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vParTestInitialise} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vParTestSetLED} (unsigned {\b portBASE_TYPE} uxLED, signed {\b portBASE_TYPE} xValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vParTestToggleLED} (unsigned {\b portBASE_TYPE} uxLED)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v partstDEFAULT_PORT_ADDRESS\:partest.h}
{\xe \v partest.h\:partstDEFAULT_PORT_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define partstDEFAULT_PORT_ADDRESS\~ ( ( unsigned short ) 0x378 )}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vParTestInitialise\:partest.h}
{\xe \v partest.h\:vParTestInitialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vParTestInitialise (void )}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vParTestSetLED\:partest.h}
{\xe \v partest.h\:vParTestSetLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vParTestSetLED (unsigned {\b portBASE_TYPE} {\i uxLED}, signed {\b portBASE_TYPE} {\i xValue})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vParTestToggleLED\:partest.h}
{\xe \v partest.h\:vParTestToggleLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vParTestToggleLED (unsigned {\b portBASE_TYPE} {\i uxLED})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/port.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/port.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/port.c}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <avr/interrupt.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portFLAGS_INT_ENABLED}\~ ( ( {\b portSTACK_TYPE} ) 0x80 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCLEAR_COUNTER_ON_MATCH}\~ ( ( unsigned char ) (1<<WGM12) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portPRESCALE_64}\~ ( ( unsigned char ) ((1<<CS11)|(1<<CS10)) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCLOCK_PRESCALER}\~ ( ( unsigned long ) 64 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCOMPARE_MATCH_A_INTERRUPT_ENABLE}\~ ( ( unsigned char ) (1<<OCIE1A) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSAVE_CONTEXT}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portRESTORE_CONTEXT}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void {\b tskTCB}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portSTACK_TYPE} * {\b pxPortInitialiseStack} ({\b portSTACK_TYPE} *pxTopOfStack, {\b pdTASK_CODE} pxCode, void *pvParameters)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xPortStartScheduler} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortEndScheduler} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortYield} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortYieldFromTick} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SIG_OUTPUT_COMPARE1A} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b tskTCB} *volatile {\b pxCurrentTCB}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pop r0 n {\b t} out {\b __SREG__}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pop r0 n t out r0 n t pop r0 n {\b t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v portCLEAR_COUNTER_ON_MATCH\:port.c}
{\xe \v port.c\:portCLEAR_COUNTER_ON_MATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCLEAR_COUNTER_ON_MATCH\~ ( ( unsigned char ) (1<<WGM12) )}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCLOCK_PRESCALER\:port.c}
{\xe \v port.c\:portCLOCK_PRESCALER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCLOCK_PRESCALER\~ ( ( unsigned long ) 64 )}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCOMPARE_MATCH_A_INTERRUPT_ENABLE\:port.c}
{\xe \v port.c\:portCOMPARE_MATCH_A_INTERRUPT_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCOMPARE_MATCH_A_INTERRUPT_ENABLE\~ ( ( unsigned char ) (1<<OCIE1A) )}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portFLAGS_INT_ENABLED\:port.c}
{\xe \v port.c\:portFLAGS_INT_ENABLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portFLAGS_INT_ENABLED\~ ( ( {\b portSTACK_TYPE} ) 0x80 )}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portPRESCALE_64\:port.c}
{\xe \v port.c\:portPRESCALE_64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portPRESCALE_64\~ ( ( unsigned char ) ((1<<CS11)|(1<<CS10)) )}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portRESTORE_CONTEXT\:port.c}
{\xe \v port.c\:portRESTORE_CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portRESTORE_CONTEXT()}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSAVE_CONTEXT\:port.c}
{\xe \v port.c\:portSAVE_CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSAVE_CONTEXT()}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v tskTCB\:port.c}
{\xe \v port.c\:tskTCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void {\b tskTCB}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pxPortInitialiseStack\:port.c}
{\xe \v port.c\:pxPortInitialiseStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portSTACK_TYPE}* pxPortInitialiseStack ({\b portSTACK_TYPE} * {\i pxTopOfStack}, {\b pdTASK_CODE} {\i pxCode}, void * {\i pvParameters})}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SIG_OUTPUT_COMPARE1A\:port.c}
{\xe \v port.c\:SIG_OUTPUT_COMPARE1A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SIG_OUTPUT_COMPARE1A (void )}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortEndScheduler\:port.c}
{\xe \v port.c\:vPortEndScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortEndScheduler (void )}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortYield\:port.c}
{\xe \v port.c\:vPortYield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortYield (void )}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortYieldFromTick\:port.c}
{\xe \v port.c\:vPortYieldFromTick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortYieldFromTick (void )}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xPortStartScheduler\:port.c}
{\xe \v port.c\:xPortStartScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xPortStartScheduler (void )}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __SREG__\:port.c}
{\xe \v port.c\:__SREG__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pop r0 n {\b t} out __SREG__}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxCurrentTCB\:port.c}
{\xe \v port.c\:pxCurrentTCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b tskTCB}* volatile pxCurrentTCB}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v t\:port.c}
{\xe \v port.c\:t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pop r0 n t out r0 n t pop r0 n t}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portable.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portable.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portable.h}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "portmacro.h"}\par
{\f2 #include "mpu_wrappers.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portBYTE_ALIGNMENT_MASK}\~ ( 0x0000 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portNUM_CONFIGURABLE_REGIONS}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portSTACK_TYPE} * {\b pxPortInitialiseStack} ({\b portSTACK_TYPE} *pxTopOfStack, {\b pdTASK_CODE} pxCode, void *pvParameters)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvPortMalloc} (size_t xSize) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortFree} (void *pv) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortInitialiseBlocks} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b xPortGetFreeHeapSize} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xPortStartScheduler} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortEndScheduler} (void) {\b PRIVILEGED_FUNCTION}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v portBYTE_ALIGNMENT_MASK\:portable.h}
{\xe \v portable.h\:portBYTE_ALIGNMENT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portBYTE_ALIGNMENT_MASK\~ ( 0x0000 )}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portNUM_CONFIGURABLE_REGIONS\:portable.h}
{\xe \v portable.h\:portNUM_CONFIGURABLE_REGIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portNUM_CONFIGURABLE_REGIONS\~ 1}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pvPortMalloc\:portable.h}
{\xe \v portable.h\:pvPortMalloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvPortMalloc (size_t {\i xSize})}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pxPortInitialiseStack\:portable.h}
{\xe \v portable.h\:pxPortInitialiseStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portSTACK_TYPE}* pxPortInitialiseStack ({\b portSTACK_TYPE} * {\i pxTopOfStack}, {\b pdTASK_CODE} {\i pxCode}, void * {\i pvParameters})}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortEndScheduler\:portable.h}
{\xe \v portable.h\:vPortEndScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortEndScheduler (void )}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortFree\:portable.h}
{\xe \v portable.h\:vPortFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortFree (void * {\i pv})}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vPortInitialiseBlocks\:portable.h}
{\xe \v portable.h\:vPortInitialiseBlocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortInitialiseBlocks (void )}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xPortGetFreeHeapSize\:portable.h}
{\xe \v portable.h\:xPortGetFreeHeapSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t xPortGetFreeHeapSize (void )}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xPortStartScheduler\:portable.h}
{\xe \v portable.h\:xPortStartScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xPortStartScheduler (void )}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portmacro.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portmacro.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/portmacro.h}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portCHAR}\~ char\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portFLOAT}\~ float\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portDOUBLE}\~ double\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portLONG}\~ long\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSHORT}\~ int\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSTACK_TYPE}\~ unsigned {\b portCHAR}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portBASE_TYPE}\~ char\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portMAX_DELAY}\~ ( {\b portTickType} ) 0xffffffff\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portENTER_CRITICAL}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portEXIT_CRITICAL}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portDISABLE_INTERRUPTS}()\~ asm volatile ( "cli" :: );\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portENABLE_INTERRUPTS}()\~ asm volatile ( "sei" :: );\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portSTACK_GROWTH}\~ ( -1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portTICK_RATE_MS}\~ ( ( {\b portTickType} ) 1000 / {\b configTICK_RATE_HZ} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portBYTE_ALIGNMENT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portNOP}()\~ asm volatile ( "nop" );\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portYIELD}()\~ {\b vPortYield}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portTASK_FUNCTION_PROTO}(vFunction, pvParameters)\~ void vFunction( void *pvParameters )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b portTASK_FUNCTION}(vFunction, pvParameters)\~ void vFunction( void *pvParameters )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned {\b portLONG} {\b portTickType}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vPortYield} (void) __attribute__((naked))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v portBASE_TYPE\:portmacro.h}
{\xe \v portmacro.h\:portBASE_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portBASE_TYPE\~ char}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portBYTE_ALIGNMENT\:portmacro.h}
{\xe \v portmacro.h\:portBYTE_ALIGNMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portBYTE_ALIGNMENT\~ 1}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portCHAR\:portmacro.h}
{\xe \v portmacro.h\:portCHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portCHAR\~ char}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portDISABLE_INTERRUPTS\:portmacro.h}
{\xe \v portmacro.h\:portDISABLE_INTERRUPTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portDISABLE_INTERRUPTS()\~ asm volatile ( "cli" :: );}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portDOUBLE\:portmacro.h}
{\xe \v portmacro.h\:portDOUBLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portDOUBLE\~ double}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portENABLE_INTERRUPTS\:portmacro.h}
{\xe \v portmacro.h\:portENABLE_INTERRUPTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portENABLE_INTERRUPTS()\~ asm volatile ( "sei" :: );}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portENTER_CRITICAL\:portmacro.h}
{\xe \v portmacro.h\:portENTER_CRITICAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portENTER_CRITICAL()}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid asm volatile ( "in      __tmp_reg__, __SREG__" :: );    \\\par
                                    asm volatile ( "cli" :: );                              \\\par
                                    asm volatile ( "push    __tmp_reg__" :: )\par
}
}
{\xe \v portEXIT_CRITICAL\:portmacro.h}
{\xe \v portmacro.h\:portEXIT_CRITICAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portEXIT_CRITICAL()}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid asm volatile ( "pop     __tmp_reg__" :: );              \\\par
                                    asm volatile ( "out     __SREG__, __tmp_reg__" :: )\par
}
}
{\xe \v portFLOAT\:portmacro.h}
{\xe \v portmacro.h\:portFLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portFLOAT\~ float}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portLONG\:portmacro.h}
{\xe \v portmacro.h\:portLONG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portLONG\~ long}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portMAX_DELAY\:portmacro.h}
{\xe \v portmacro.h\:portMAX_DELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portMAX_DELAY\~ ( {\b portTickType} ) 0xffffffff}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portNOP\:portmacro.h}
{\xe \v portmacro.h\:portNOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portNOP()\~ asm volatile ( "nop" );}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSHORT\:portmacro.h}
{\xe \v portmacro.h\:portSHORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSHORT\~ int}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSTACK_GROWTH\:portmacro.h}
{\xe \v portmacro.h\:portSTACK_GROWTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSTACK_GROWTH\~ ( -1 )}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portSTACK_TYPE\:portmacro.h}
{\xe \v portmacro.h\:portSTACK_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portSTACK_TYPE\~ unsigned {\b portCHAR}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portTASK_FUNCTION\:portmacro.h}
{\xe \v portmacro.h\:portTASK_FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portTASK_FUNCTION( vFunction,  pvParameters)\~ void vFunction( void *pvParameters )}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portTASK_FUNCTION_PROTO\:portmacro.h}
{\xe \v portmacro.h\:portTASK_FUNCTION_PROTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portTASK_FUNCTION_PROTO( vFunction,  pvParameters)\~ void vFunction( void *pvParameters )}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portTICK_RATE_MS\:portmacro.h}
{\xe \v portmacro.h\:portTICK_RATE_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portTICK_RATE_MS\~ ( ( {\b portTickType} ) 1000 / {\b configTICK_RATE_HZ} )}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portYIELD\:portmacro.h}
{\xe \v portmacro.h\:portYIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define portYIELD()\~ {\b vPortYield}()}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v portTickType\:portmacro.h}
{\xe \v portmacro.h\:portTickType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned {\b portLONG} {\b portTickType}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vPortYield\:portmacro.h}
{\xe \v portmacro.h\:vPortYield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vPortYield (void )}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/projdefs.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/projdefs.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/projdefs.h}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pdTRUE}\~ ( 1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pdFALSE}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pdPASS}\~ ( 1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pdFAIL}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errQUEUE_EMPTY}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errQUEUE_FULL}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY}\~ ( -1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errNO_TASK_TO_RUN}\~ ( -2 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errQUEUE_BLOCKED}\~ ( -4 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b errQUEUE_YIELD}\~ ( -5 )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b pdTASK_CODE} )(void *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY\:projdefs.h}
{\xe \v projdefs.h\:errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY\~ ( -1 )}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errNO_TASK_TO_RUN\:projdefs.h}
{\xe \v projdefs.h\:errNO_TASK_TO_RUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errNO_TASK_TO_RUN\~ ( -2 )}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errQUEUE_BLOCKED\:projdefs.h}
{\xe \v projdefs.h\:errQUEUE_BLOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errQUEUE_BLOCKED\~ ( -4 )}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errQUEUE_EMPTY\:projdefs.h}
{\xe \v projdefs.h\:errQUEUE_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errQUEUE_EMPTY\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errQUEUE_FULL\:projdefs.h}
{\xe \v projdefs.h\:errQUEUE_FULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errQUEUE_FULL\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errQUEUE_YIELD\:projdefs.h}
{\xe \v projdefs.h\:errQUEUE_YIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define errQUEUE_YIELD\~ ( -5 )}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pdFAIL\:projdefs.h}
{\xe \v projdefs.h\:pdFAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pdFAIL\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pdFALSE\:projdefs.h}
{\xe \v projdefs.h\:pdFALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pdFALSE\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pdPASS\:projdefs.h}
{\xe \v projdefs.h\:pdPASS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pdPASS\~ ( 1 )}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pdTRUE\:projdefs.h}
{\xe \v projdefs.h\:pdTRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pdTRUE\~ ( 1 )}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v pdTASK_CODE\:projdefs.h}
{\xe \v projdefs.h\:pdTASK_CODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* pdTASK_CODE)(void *)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.c}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QueueDefinition}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MPU_WRAPPERS_INCLUDED_FROM_API_FILE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueUNLOCKED}\~ ( ( signed {\b portBASE_TYPE} ) -1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueLOCKED_UNMODIFIED}\~ ( ( signed {\b portBASE_TYPE} ) 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueERRONEOUS_UNBLOCK}\~ ( -1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueSEND_TO_BACK}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueSEND_TO_FRONT}\~ ( 1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pxMutexHolder}\~ pcTail\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uxQueueType}\~ pcHead\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uxRecursiveCallCount}\~ pcReadFrom\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_IS_MUTEX}\~ NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueSEMAPHORE_QUEUE_ITEM_LENGTH}\~ ( ( unsigned {\b portBASE_TYPE} ) 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueDONT_BLOCK}\~ ( ( {\b portTickType} ) 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueMUTEX_GIVE_BLOCK_TIME}\~ ( ( {\b portTickType} ) 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_BASE}\~ ( 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_MUTEX}\~ ( 1U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_COUNTING_SEMAPHORE}\~ ( 2U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_BINARY_SEMAPHORE}\~ ( 3U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_RECURSIVE_MUTEX}\~ ( 4U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvLockQueue}(pxQueue)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b QueueDefinition} {\b xQUEUE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b xQUEUE} * {\b xQueueHandle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueGenericCreate} (unsigned {\b portBASE_TYPE} uxQueueLength, unsigned {\b portBASE_TYPE} uxItemSize, unsigned char ucQueueType) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericSend} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xCopyPosition) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxQueueMessagesWaiting} (const {\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vQueueDelete} ({\b xQueueHandle} xQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericSendFromISR} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, signed {\b portBASE_TYPE} *pxHigherPriorityTaskWoken, {\b portBASE_TYPE} xCopyPosition) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericReceive} ({\b xQueueHandle} pxQueue, void *const pvBuffer, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xJustPeeking) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueReceiveFromISR} ({\b xQueueHandle} pxQueue, void *const pvBuffer, signed {\b portBASE_TYPE} *pxHigherPriorityTaskWoken) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueCreateMutex} (unsigned char ucQueueType) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueCreateCountingSemaphore} (unsigned {\b portBASE_TYPE} uxCountValue, unsigned {\b portBASE_TYPE} uxInitialCount) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueTakeMutexRecursive} ({\b xQueueHandle} xMutex, {\b portTickType} xBlockTime) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueGiveMutexRecursive} ({\b xQueueHandle} xMutex) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueAltGenericSend} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xCopyPosition) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueAltGenericReceive} ({\b xQueueHandle} pxQueue, void *const pvBuffer, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xJustPeeking) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueIsQueueEmptyFromISR} (const {\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueIsQueueFullFromISR} (const {\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxQueueMessagesWaitingFromISR} (const {\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vQueueWaitForMessageRestricted} ({\b xQueueHandle} pxQueue, {\b portTickType} xTicksToWait) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ucQueueGetQueueNumber} ({\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vQueueSetQueueNumber} ({\b xQueueHandle} pxQueue, unsigned char ucQueueNumber) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ucQueueGetQueueType} ({\b xQueueHandle} pxQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueGenericReset} ({\b xQueueHandle} pxQueue, {\b portBASE_TYPE} xNewQueue) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xTaskHandle} {\b xQueueGetMutexHolder} ({\b xQueueHandle} xSemaphore) {\b PRIVILEGED_FUNCTION}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MPU_WRAPPERS_INCLUDED_FROM_API_FILE\:queue.c}
{\xe \v queue.c\:MPU_WRAPPERS_INCLUDED_FROM_API_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prvLockQueue\:queue.c}
{\xe \v queue.c\:prvLockQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvLockQueue( pxQueue)}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid taskENTER_CRITICAL();                                   \\\par
    \{                                                       \\\par
        if( ( pxQueue )->xRxLock == queueUNLOCKED )         \\\par
        \{                                                   \\\par
            ( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;  \\\par
        \}                                                   \\\par
        if( ( pxQueue )->xTxLock == queueUNLOCKED )         \\\par
        \{                                                   \\\par
            ( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;  \\\par
        \}                                                   \\\par
    \}                                                       \\\par
    taskEXIT_CRITICAL()\par
}
}
{\xe \v pxMutexHolder\:queue.c}
{\xe \v queue.c\:pxMutexHolder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pxMutexHolder\~ pcTail}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueDONT_BLOCK\:queue.c}
{\xe \v queue.c\:queueDONT_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueDONT_BLOCK\~ ( ( {\b portTickType} ) 0U )}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueERRONEOUS_UNBLOCK\:queue.c}
{\xe \v queue.c\:queueERRONEOUS_UNBLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueERRONEOUS_UNBLOCK\~ ( -1 )}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueLOCKED_UNMODIFIED\:queue.c}
{\xe \v queue.c\:queueLOCKED_UNMODIFIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueLOCKED_UNMODIFIED\~ ( ( signed {\b portBASE_TYPE} ) 0 )}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueMUTEX_GIVE_BLOCK_TIME\:queue.c}
{\xe \v queue.c\:queueMUTEX_GIVE_BLOCK_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueMUTEX_GIVE_BLOCK_TIME\~ ( ( {\b portTickType} ) 0U )}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_IS_MUTEX\:queue.c}
{\xe \v queue.c\:queueQUEUE_IS_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_IS_MUTEX\~ NULL}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_BASE\:queue.c}
{\xe \v queue.c\:queueQUEUE_TYPE_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_BASE\~ ( 0U )}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_BINARY_SEMAPHORE\:queue.c}
{\xe \v queue.c\:queueQUEUE_TYPE_BINARY_SEMAPHORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_BINARY_SEMAPHORE\~ ( 3U )}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_COUNTING_SEMAPHORE\:queue.c}
{\xe \v queue.c\:queueQUEUE_TYPE_COUNTING_SEMAPHORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_COUNTING_SEMAPHORE\~ ( 2U )}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_MUTEX\:queue.c}
{\xe \v queue.c\:queueQUEUE_TYPE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_MUTEX\~ ( 1U )}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_RECURSIVE_MUTEX\:queue.c}
{\xe \v queue.c\:queueQUEUE_TYPE_RECURSIVE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_RECURSIVE_MUTEX\~ ( 4U )}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueSEMAPHORE_QUEUE_ITEM_LENGTH\:queue.c}
{\xe \v queue.c\:queueSEMAPHORE_QUEUE_ITEM_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueSEMAPHORE_QUEUE_ITEM_LENGTH\~ ( ( unsigned {\b portBASE_TYPE} ) 0 )}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueSEND_TO_BACK\:queue.c}
{\xe \v queue.c\:queueSEND_TO_BACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueSEND_TO_BACK\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueSEND_TO_FRONT\:queue.c}
{\xe \v queue.c\:queueSEND_TO_FRONT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueSEND_TO_FRONT\~ ( 1 )}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueUNLOCKED\:queue.c}
{\xe \v queue.c\:queueUNLOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueUNLOCKED\~ ( ( signed {\b portBASE_TYPE} ) -1 )}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxQueueType\:queue.c}
{\xe \v queue.c\:uxQueueType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uxQueueType\~ pcHead}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxRecursiveCallCount\:queue.c}
{\xe \v queue.c\:uxRecursiveCallCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uxRecursiveCallCount\~ pcReadFrom}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v xQUEUE\:queue.c}
{\xe \v queue.c\:xQUEUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b QueueDefinition}  {\b xQUEUE}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueHandle\:queue.c}
{\xe \v queue.c\:xQueueHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b xQUEUE}* {\b xQueueHandle}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ucQueueGetQueueNumber\:queue.c}
{\xe \v queue.c\:ucQueueGetQueueNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char ucQueueGetQueueNumber ({\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ucQueueGetQueueType\:queue.c}
{\xe \v queue.c\:ucQueueGetQueueType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char ucQueueGetQueueType ({\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxQueueMessagesWaiting\:queue.c}
{\xe \v queue.c\:uxQueueMessagesWaiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxQueueMessagesWaiting (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxQueueMessagesWaitingFromISR\:queue.c}
{\xe \v queue.c\:uxQueueMessagesWaitingFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxQueueMessagesWaitingFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueDelete\:queue.c}
{\xe \v queue.c\:vQueueDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vQueueDelete ({\b xQueueHandle} {\i xQueue})}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueSetQueueNumber\:queue.c}
{\xe \v queue.c\:vQueueSetQueueNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vQueueSetQueueNumber ({\b xQueueHandle} {\i pxQueue}, unsigned char {\i ucQueueNumber})}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueWaitForMessageRestricted\:queue.c}
{\xe \v queue.c\:vQueueWaitForMessageRestricted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vQueueWaitForMessageRestricted ({\b xQueueHandle} {\i pxQueue}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltGenericReceive\:queue.c}
{\xe \v queue.c\:xQueueAltGenericReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueAltGenericReceive ({\b xQueueHandle} {\i pxQueue}, void *const {\i pvBuffer}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xJustPeeking})}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltGenericSend\:queue.c}
{\xe \v queue.c\:xQueueAltGenericSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueAltGenericSend ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCreateCountingSemaphore\:queue.c}
{\xe \v queue.c\:xQueueCreateCountingSemaphore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueCreateCountingSemaphore (unsigned {\b portBASE_TYPE} {\i uxCountValue}, unsigned {\b portBASE_TYPE} {\i uxInitialCount})}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCreateMutex\:queue.c}
{\xe \v queue.c\:xQueueCreateMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueCreateMutex (unsigned char {\i ucQueueType})}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericCreate\:queue.c}
{\xe \v queue.c\:xQueueGenericCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueGenericCreate (unsigned {\b portBASE_TYPE} {\i uxQueueLength}, unsigned {\b portBASE_TYPE} {\i uxItemSize}, unsigned char {\i ucQueueType})}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericReceive\:queue.c}
{\xe \v queue.c\:xQueueGenericReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericReceive ({\b xQueueHandle} {\i pxQueue}, void *const {\i pvBuffer}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xJustPeeking})}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericReset\:queue.c}
{\xe \v queue.c\:xQueueGenericReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueGenericReset ({\b xQueueHandle} {\i pxQueue}, {\b portBASE_TYPE} {\i xNewQueue})}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericSend\:queue.c}
{\xe \v queue.c\:xQueueGenericSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericSend ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericSendFromISR\:queue.c}
{\xe \v queue.c\:xQueueGenericSendFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericSendFromISR ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, signed {\b portBASE_TYPE} * {\i pxHigherPriorityTaskWoken}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGetMutexHolder\:queue.c}
{\xe \v queue.c\:xQueueGetMutexHolder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xTaskHandle} xQueueGetMutexHolder ({\b xQueueHandle} {\i xSemaphore})}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGiveMutexRecursive\:queue.c}
{\xe \v queue.c\:xQueueGiveMutexRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueGiveMutexRecursive ({\b xQueueHandle} {\i xMutex})}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueIsQueueEmptyFromISR\:queue.c}
{\xe \v queue.c\:xQueueIsQueueEmptyFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueIsQueueEmptyFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueIsQueueFullFromISR\:queue.c}
{\xe \v queue.c\:xQueueIsQueueFullFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueIsQueueFullFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueReceiveFromISR\:queue.c}
{\xe \v queue.c\:xQueueReceiveFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueReceiveFromISR ({\b xQueueHandle} {\i pxQueue}, void *const {\i pvBuffer}, signed {\b portBASE_TYPE} * {\i pxHigherPriorityTaskWoken})}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueTakeMutexRecursive\:queue.c}
{\xe \v queue.c\:xQueueTakeMutexRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueTakeMutexRecursive ({\b xQueueHandle} {\i xMutex}, {\b portTickType} {\i xBlockTime})}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/queue.h}
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mpu_wrappers.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueSEND_TO_BACK}\~ ( 0 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueSEND_TO_FRONT}\~ ( 1 )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_BASE}\~ ( 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_MUTEX}\~ ( 1U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_COUNTING_SEMAPHORE}\~ ( 2U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_BINARY_SEMAPHORE}\~ ( 3U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b queueQUEUE_TYPE_RECURSIVE_MUTEX}\~ ( 4U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueCreate}(uxQueueLength, uxItemSize)\~ {\b xQueueGenericCreate}( uxQueueLength, uxItemSize, {\b queueQUEUE_TYPE_BASE} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSendToFront}(xQueue, pvItemToQueue, xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_FRONT} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSendToBack}(xQueue, pvItemToQueue, xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSend}(xQueue, pvItemToQueue, xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueuePeek}(xQueue, pvBuffer, xTicksToWait)\~ {\b xQueueGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdTRUE} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueReceive}(xQueue, pvBuffer, xTicksToWait)\~ {\b xQueueGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdFALSE} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSendToFrontFromISR}(pxQueue, pvItemToQueue, pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_FRONT} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSendToBackFromISR}(pxQueue, pvItemToQueue, pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_BACK} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueSendFromISR}(pxQueue, pvItemToQueue, pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_BACK} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueAltSendToFront}(xQueue, pvItemToQueue, xTicksToWait)\~ {\b xQueueAltGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_FRONT} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueAltSendToBack}(xQueue, pvItemToQueue, xTicksToWait)\~ {\b xQueueAltGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueAltReceive}(xQueue, pvBuffer, xTicksToWait)\~ {\b xQueueAltGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdFALSE} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueAltPeek}(xQueue, pvBuffer, xTicksToWait)\~ {\b xQueueAltGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdTRUE} )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xQueueReset}(pxQueue)\~ {\b xQueueGenericReset}( pxQueue, {\b pdFALSE} )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b xQueueHandle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericSend} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xCopyPosition)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericReceive} ({\b xQueueHandle} xQueue, void *const pvBuffer, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xJustPeek)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxQueueMessagesWaiting} (const {\b xQueueHandle} xQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vQueueDelete} ({\b xQueueHandle} pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueGenericSendFromISR} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, signed {\b portBASE_TYPE} *pxHigherPriorityTaskWoken, {\b portBASE_TYPE} xCopyPosition)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueReceiveFromISR} ({\b xQueueHandle} pxQueue, void *const pvBuffer, signed {\b portBASE_TYPE} *pxHigherPriorityTaskWoken)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueIsQueueEmptyFromISR} (const {\b xQueueHandle} pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueIsQueueFullFromISR} (const {\b xQueueHandle} pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxQueueMessagesWaitingFromISR} (const {\b xQueueHandle} pxQueue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueAltGenericSend} ({\b xQueueHandle} pxQueue, const void *const pvItemToQueue, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xCopyPosition)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueAltGenericReceive} ({\b xQueueHandle} pxQueue, void *const pvBuffer, {\b portTickType} xTicksToWait, {\b portBASE_TYPE} xJustPeeking)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueCRSendFromISR} ({\b xQueueHandle} pxQueue, const void *pvItemToQueue, signed {\b portBASE_TYPE} xCoRoutinePreviouslyWoken)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueCRReceiveFromISR} ({\b xQueueHandle} pxQueue, void *pvBuffer, signed {\b portBASE_TYPE} *pxTaskWoken)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueCRSend} ({\b xQueueHandle} pxQueue, const void *pvItemToQueue, {\b portTickType} xTicksToWait)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xQueueCRReceive} ({\b xQueueHandle} pxQueue, void *pvBuffer, {\b portTickType} xTicksToWait)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueCreateMutex} (unsigned char ucQueueType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueCreateCountingSemaphore} (unsigned {\b portBASE_TYPE} uxCountValue, unsigned {\b portBASE_TYPE} uxInitialCount)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b xQueueGetMutexHolder} ({\b xQueueHandle} xSemaphore)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueTakeMutexRecursive} ({\b xQueueHandle} pxMutex, {\b portTickType} xBlockTime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueGiveMutexRecursive} ({\b xQueueHandle} pxMutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xQueueHandle} {\b xQueueGenericCreate} (unsigned {\b portBASE_TYPE} uxQueueLength, unsigned {\b portBASE_TYPE} uxItemSize, unsigned char ucQueueType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vQueueWaitForMessageRestricted} ({\b xQueueHandle} pxQueue, {\b portTickType} xTicksToWait)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xQueueGenericReset} ({\b xQueueHandle} pxQueue, {\b portBASE_TYPE} xNewQueue)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v queueQUEUE_TYPE_BASE\:queue.h}
{\xe \v queue.h\:queueQUEUE_TYPE_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_BASE\~ ( 0U )}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_BINARY_SEMAPHORE\:queue.h}
{\xe \v queue.h\:queueQUEUE_TYPE_BINARY_SEMAPHORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_BINARY_SEMAPHORE\~ ( 3U )}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_COUNTING_SEMAPHORE\:queue.h}
{\xe \v queue.h\:queueQUEUE_TYPE_COUNTING_SEMAPHORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_COUNTING_SEMAPHORE\~ ( 2U )}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_MUTEX\:queue.h}
{\xe \v queue.h\:queueQUEUE_TYPE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_MUTEX\~ ( 1U )}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueQUEUE_TYPE_RECURSIVE_MUTEX\:queue.h}
{\xe \v queue.h\:queueQUEUE_TYPE_RECURSIVE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueQUEUE_TYPE_RECURSIVE_MUTEX\~ ( 4U )}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueSEND_TO_BACK\:queue.h}
{\xe \v queue.h\:queueSEND_TO_BACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueSEND_TO_BACK\~ ( 0 )}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v queueSEND_TO_FRONT\:queue.h}
{\xe \v queue.h\:queueSEND_TO_FRONT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define queueSEND_TO_FRONT\~ ( 1 )}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltPeek\:queue.h}
{\xe \v queue.h\:xQueueAltPeek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueAltPeek( xQueue,  pvBuffer,  xTicksToWait)\~ {\b xQueueAltGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdTRUE} )}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltReceive\:queue.h}
{\xe \v queue.h\:xQueueAltReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueAltReceive( xQueue,  pvBuffer,  xTicksToWait)\~ {\b xQueueAltGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdFALSE} )}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltSendToBack\:queue.h}
{\xe \v queue.h\:xQueueAltSendToBack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueAltSendToBack( xQueue,  pvItemToQueue,  xTicksToWait)\~ {\b xQueueAltGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltSendToFront\:queue.h}
{\xe \v queue.h\:xQueueAltSendToFront}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueAltSendToFront( xQueue,  pvItemToQueue,  xTicksToWait)\~ {\b xQueueAltGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_FRONT} )}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCreate\:queue.h}
{\xe \v queue.h\:xQueueCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueCreate( uxQueueLength,  uxItemSize)\~ {\b xQueueGenericCreate}( uxQueueLength, uxItemSize, {\b queueQUEUE_TYPE_BASE} )}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueuePeek\:queue.h}
{\xe \v queue.h\:xQueuePeek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueuePeek( xQueue,  pvBuffer,  xTicksToWait)\~ {\b xQueueGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdTRUE} )}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueReceive\:queue.h}
{\xe \v queue.h\:xQueueReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueReceive( xQueue,  pvBuffer,  xTicksToWait)\~ {\b xQueueGenericReceive}( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), {\b pdFALSE} )}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueReset\:queue.h}
{\xe \v queue.h\:xQueueReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueReset( pxQueue)\~ {\b xQueueGenericReset}( pxQueue, {\b pdFALSE} )}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSend\:queue.h}
{\xe \v queue.h\:xQueueSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSend( xQueue,  pvItemToQueue,  xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSendFromISR\:queue.h}
{\xe \v queue.h\:xQueueSendFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSendFromISR( pxQueue,  pvItemToQueue,  pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_BACK} )}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSendToBack\:queue.h}
{\xe \v queue.h\:xQueueSendToBack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSendToBack( xQueue,  pvItemToQueue,  xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_BACK} )}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSendToBackFromISR\:queue.h}
{\xe \v queue.h\:xQueueSendToBackFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSendToBackFromISR( pxQueue,  pvItemToQueue,  pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_BACK} )}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSendToFront\:queue.h}
{\xe \v queue.h\:xQueueSendToFront}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSendToFront( xQueue,  pvItemToQueue,  xTicksToWait)\~ {\b xQueueGenericSend}( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), {\b queueSEND_TO_FRONT} )}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueSendToFrontFromISR\:queue.h}
{\xe \v queue.h\:xQueueSendToFrontFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xQueueSendToFrontFromISR( pxQueue,  pvItemToQueue,  pxHigherPriorityTaskWoken)\~ {\b xQueueGenericSendFromISR}( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), {\b queueSEND_TO_FRONT} )}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v xQueueHandle\:queue.h}
{\xe \v queue.h\:xQueueHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b xQueueHandle}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type by which queues are referenced. For example, a call to xQueueCreate returns (via a pointer parameter) an xQueueHandle variable that can then be used as a parameter to {\b xQueueSend()}, {\b xQueueReceive()}, etc. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v uxQueueMessagesWaiting\:queue.h}
{\xe \v queue.h\:uxQueueMessagesWaiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxQueueMessagesWaiting (const {\b xQueueHandle} {\i xQueue})}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxQueueMessagesWaitingFromISR\:queue.h}
{\xe \v queue.h\:uxQueueMessagesWaitingFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxQueueMessagesWaitingFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueDelete\:queue.h}
{\xe \v queue.h\:vQueueDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vQueueDelete ({\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vQueueWaitForMessageRestricted\:queue.h}
{\xe \v queue.h\:vQueueWaitForMessageRestricted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vQueueWaitForMessageRestricted ({\b xQueueHandle} {\i pxQueue}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltGenericReceive\:queue.h}
{\xe \v queue.h\:xQueueAltGenericReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueAltGenericReceive ({\b xQueueHandle} {\i pxQueue}, void *const {\i pvBuffer}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xJustPeeking})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueAltGenericSend\:queue.h}
{\xe \v queue.h\:xQueueAltGenericSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueAltGenericSend ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCreateCountingSemaphore\:queue.h}
{\xe \v queue.h\:xQueueCreateCountingSemaphore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueCreateCountingSemaphore (unsigned {\b portBASE_TYPE} {\i uxCountValue}, unsigned {\b portBASE_TYPE} {\i uxInitialCount})}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCreateMutex\:queue.h}
{\xe \v queue.h\:xQueueCreateMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueCreateMutex (unsigned char {\i ucQueueType})}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCRReceive\:queue.h}
{\xe \v queue.h\:xQueueCRReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueCRReceive ({\b xQueueHandle} {\i pxQueue}, void * {\i pvBuffer}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCRReceiveFromISR\:queue.h}
{\xe \v queue.h\:xQueueCRReceiveFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueCRReceiveFromISR ({\b xQueueHandle} {\i pxQueue}, void * {\i pvBuffer}, signed {\b portBASE_TYPE} * {\i pxTaskWoken})}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCRSend\:queue.h}
{\xe \v queue.h\:xQueueCRSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueCRSend ({\b xQueueHandle} {\i pxQueue}, const void * {\i pvItemToQueue}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueCRSendFromISR\:queue.h}
{\xe \v queue.h\:xQueueCRSendFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueCRSendFromISR ({\b xQueueHandle} {\i pxQueue}, const void * {\i pvItemToQueue}, signed {\b portBASE_TYPE} {\i xCoRoutinePreviouslyWoken})}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericCreate\:queue.h}
{\xe \v queue.h\:xQueueGenericCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xQueueHandle} xQueueGenericCreate (unsigned {\b portBASE_TYPE} {\i uxQueueLength}, unsigned {\b portBASE_TYPE} {\i uxItemSize}, unsigned char {\i ucQueueType})}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericReceive\:queue.h}
{\xe \v queue.h\:xQueueGenericReceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericReceive ({\b xQueueHandle} {\i xQueue}, void *const {\i pvBuffer}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xJustPeek})}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericReset\:queue.h}
{\xe \v queue.h\:xQueueGenericReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueGenericReset ({\b xQueueHandle} {\i pxQueue}, {\b portBASE_TYPE} {\i xNewQueue})}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericSend\:queue.h}
{\xe \v queue.h\:xQueueGenericSend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericSend ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, {\b portTickType} {\i xTicksToWait}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGenericSendFromISR\:queue.h}
{\xe \v queue.h\:xQueueGenericSendFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueGenericSendFromISR ({\b xQueueHandle} {\i pxQueue}, const void *const {\i pvItemToQueue}, signed {\b portBASE_TYPE} * {\i pxHigherPriorityTaskWoken}, {\b portBASE_TYPE} {\i xCopyPosition})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGetMutexHolder\:queue.h}
{\xe \v queue.h\:xQueueGetMutexHolder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* xQueueGetMutexHolder ({\b xQueueHandle} {\i xSemaphore})}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueGiveMutexRecursive\:queue.h}
{\xe \v queue.h\:xQueueGiveMutexRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueGiveMutexRecursive ({\b xQueueHandle} {\i pxMutex})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueIsQueueEmptyFromISR\:queue.h}
{\xe \v queue.h\:xQueueIsQueueEmptyFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueIsQueueEmptyFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueIsQueueFullFromISR\:queue.h}
{\xe \v queue.h\:xQueueIsQueueFullFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueIsQueueFullFromISR (const {\b xQueueHandle} {\i pxQueue})}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueReceiveFromISR\:queue.h}
{\xe \v queue.h\:xQueueReceiveFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xQueueReceiveFromISR ({\b xQueueHandle} {\i pxQueue}, void *const {\i pvBuffer}, signed {\b portBASE_TYPE} * {\i pxHigherPriorityTaskWoken})}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xQueueTakeMutexRecursive\:queue.h}
{\xe \v queue.h\:xQueueTakeMutexRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xQueueTakeMutexRecursive ({\b xQueueHandle} {\i pxMutex}, {\b portTickType} {\i xBlockTime})}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/StackMacros.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/StackMacros.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/StackMacros.h}
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskFIRST_CHECK_FOR_STACK_OVERFLOW}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskSECOND_CHECK_FOR_STACK_OVERFLOW}()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v taskFIRST_CHECK_FOR_STACK_OVERFLOW\:StackMacros.h}
{\xe \v StackMacros.h\:taskFIRST_CHECK_FOR_STACK_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskSECOND_CHECK_FOR_STACK_OVERFLOW\:StackMacros.h}
{\xe \v StackMacros.h\:taskSECOND_CHECK_FOR_STACK_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/task.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/task.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/task.h}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "portable.h"}\par
{\f2 #include "list.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xTIME_OUT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xMEMORY_REGION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b xTASK_PARAMTERS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskKERNEL_VERSION_NUMBER}\~ "V7.2.0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskIDLE_PRIORITY}\~ ( ( unsigned {\b portBASE_TYPE} ) 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskYIELD}()\~ {\b portYIELD}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskENTER_CRITICAL}()\~ {\b portENTER_CRITICAL}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskEXIT_CRITICAL}()\~ {\b portEXIT_CRITICAL}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskDISABLE_INTERRUPTS}()\~ {\b portDISABLE_INTERRUPTS}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskENABLE_INTERRUPTS}()\~ {\b portENABLE_INTERRUPTS}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskSCHEDULER_NOT_STARTED}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskSCHEDULER_RUNNING}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b taskSCHEDULER_SUSPENDED}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTaskCreate}(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)\~ {\b xTaskGenericCreate}( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTaskCreateRestricted}(x, pxCreatedTask)\~ {\b xTaskGenericCreate}( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b xTaskHandle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xTIME_OUT} {\b xTimeOutType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xMEMORY_REGION} {\b xMemoryRegion}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b xTASK_PARAMTERS} {\b xTaskParameters}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskAllocateMPURegions} ({\b xTaskHandle} xTask, const {\b xMemoryRegion} *const pxRegions) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelete} ({\b xTaskHandle} pxTaskToDelete) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelay} ({\b portTickType} xTicksToDelay) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelayUntil} ({\b portTickType} *const pxPreviousWakeTime, {\b portTickType} xTimeIncrement) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxTaskPriorityGet} ({\b xTaskHandle} pxTask) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPrioritySet} ({\b xTaskHandle} pxTask, unsigned {\b portBASE_TYPE} uxNewPriority) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSuspend} ({\b xTaskHandle} pxTaskToSuspend) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskResume} ({\b xTaskHandle} pxTaskToResume) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskResumeFromISR} ({\b xTaskHandle} pxTaskToResume) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskStartScheduler} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskEndScheduler} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSuspendAll} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskResumeAll} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskIsTaskSuspended} ({\b xTaskHandle} xTask) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xTaskGetTickCount} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xTaskGetTickCountFromISR} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxTaskGetNumberOfTasks} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed char * {\b pcTaskGetTaskName} ({\b xTaskHandle} xTaskToQuery)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskList} (signed char *pcWriteBuffer) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskGetRunTimeStats} (signed char *pcWriteBuffer) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxTaskGetStackHighWaterMark} ({\b xTaskHandle} xTask) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskCallApplicationTaskHook} ({\b xTaskHandle} xTask, void *pvParameter) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xTaskHandle} {\b xTaskGetIdleTaskHandle} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskIncrementTick} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPlaceOnEventList} (const {\b xList} *const pxEventList, {\b portTickType} xTicksToWait) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPlaceOnEventListRestricted} (const {\b xList} *const pxEventList, {\b portTickType} xTicksToWait) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskRemoveFromEventList} (const {\b xList} *const pxEventList) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSwitchContext} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xTaskHandle} {\b xTaskGetCurrentTaskHandle} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSetTimeOutState} ({\b xTimeOutType} *const pxTimeOut) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskCheckForTimeOut} ({\b xTimeOutType} *const pxTimeOut, {\b portTickType} *const pxTicksToWait) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskMissedYield} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskGetSchedulerState} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPriorityInherit} ({\b xTaskHandle} *const {\b pxMutexHolder}) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPriorityDisinherit} ({\b xTaskHandle} *const {\b pxMutexHolder}) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskGenericCreate} ({\b pdTASK_CODE} pxTaskCode, const signed char *const pcName, unsigned short usStackDepth, void *pvParameters, unsigned {\b portBASE_TYPE} uxPriority, {\b xTaskHandle} *pxCreatedTask, {\b portSTACK_TYPE} *puxStackBuffer, const {\b xMemoryRegion} *const xRegions) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxTaskGetTaskNumber} ({\b xTaskHandle} xTask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSetTaskNumber} ({\b xTaskHandle} xTask, unsigned {\b portBASE_TYPE} uxHandle)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v taskDISABLE_INTERRUPTS\:task.h}
{\xe \v task.h\:taskDISABLE_INTERRUPTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskDISABLE_INTERRUPTS()\~ {\b portDISABLE_INTERRUPTS}()}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskENABLE_INTERRUPTS\:task.h}
{\xe \v task.h\:taskENABLE_INTERRUPTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskENABLE_INTERRUPTS()\~ {\b portENABLE_INTERRUPTS}()}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskENTER_CRITICAL\:task.h}
{\xe \v task.h\:taskENTER_CRITICAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskENTER_CRITICAL()\~ {\b portENTER_CRITICAL}()}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskEXIT_CRITICAL\:task.h}
{\xe \v task.h\:taskEXIT_CRITICAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskEXIT_CRITICAL()\~ {\b portEXIT_CRITICAL}()}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskSCHEDULER_NOT_STARTED\:task.h}
{\xe \v task.h\:taskSCHEDULER_NOT_STARTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskSCHEDULER_NOT_STARTED\~ 0}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskSCHEDULER_RUNNING\:task.h}
{\xe \v task.h\:taskSCHEDULER_RUNNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskSCHEDULER_RUNNING\~ 1}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskSCHEDULER_SUSPENDED\:task.h}
{\xe \v task.h\:taskSCHEDULER_SUSPENDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskSCHEDULER_SUSPENDED\~ 2}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v taskYIELD\:task.h}
{\xe \v task.h\:taskYIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define taskYIELD()\~ {\b portYIELD}()}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskIDLE_PRIORITY\:task.h}
{\xe \v task.h\:tskIDLE_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskIDLE_PRIORITY\~ ( ( unsigned {\b portBASE_TYPE} ) 0U )}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskKERNEL_VERSION_NUMBER\:task.h}
{\xe \v task.h\:tskKERNEL_VERSION_NUMBER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskKERNEL_VERSION_NUMBER\~ "V7.2.0"}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskCreate\:task.h}
{\xe \v task.h\:xTaskCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTaskCreate( pvTaskCode,  pcName,  usStackDepth,  pvParameters,  uxPriority,  pxCreatedTask)\~ {\b xTaskGenericCreate}( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskCreateRestricted\:task.h}
{\xe \v task.h\:xTaskCreateRestricted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTaskCreateRestricted( x,  pxCreatedTask)\~ {\b xTaskGenericCreate}( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v xMemoryRegion\:task.h}
{\xe \v task.h\:xMemoryRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xMEMORY_REGION}  {\b xMemoryRegion}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskHandle\:task.h}
{\xe \v task.h\:xTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b xTaskHandle}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskParameters\:task.h}
{\xe \v task.h\:xTaskParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xTASK_PARAMTERS}  {\b xTaskParameters}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimeOutType\:task.h}
{\xe \v task.h\:xTimeOutType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b xTIME_OUT}  {\b xTimeOutType}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pcTaskGetTaskName\:task.h}
{\xe \v task.h\:pcTaskGetTaskName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed char* pcTaskGetTaskName ({\b xTaskHandle} {\i xTaskToQuery})}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxTaskGetNumberOfTasks\:task.h}
{\xe \v task.h\:uxTaskGetNumberOfTasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxTaskGetNumberOfTasks (void )}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxTaskGetStackHighWaterMark\:task.h}
{\xe \v task.h\:uxTaskGetStackHighWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxTaskGetStackHighWaterMark ({\b xTaskHandle} {\i xTask})}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b task.h} {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid unsigned portBASE_TYPE {\b uxTaskGetStackHighWaterMark( xTaskHandle xTask )};\par}
INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in {\b FreeRTOSConfig.h} for this function to be available.\par
Returns the high water mark of the stack associated with xTask. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTask} \cell }{Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The smallest amount of free stack space there has been (in bytes) since the task referenced by xTask was created. \par
}}}
{\xe \v uxTaskGetTaskNumber\:task.h}
{\xe \v task.h\:uxTaskGetTaskNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxTaskGetTaskNumber ({\b xTaskHandle} {\i xTask})}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v uxTaskPriorityGet\:task.h}
{\xe \v task.h\:uxTaskPriorityGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxTaskPriorityGet ({\b xTaskHandle} {\i pxTask})}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskAllocateMPURegions\:task.h}
{\xe \v task.h\:vTaskAllocateMPURegions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskAllocateMPURegions ({\b xTaskHandle} {\i xTask}, const {\b xMemoryRegion} *const {\i pxRegions})}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelay\:task.h}
{\xe \v task.h\:vTaskDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelay ({\b portTickType} {\i xTicksToDelay})}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelayUntil\:task.h}
{\xe \v task.h\:vTaskDelayUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelayUntil ({\b portTickType} *const {\i pxPreviousWakeTime}, {\b portTickType} {\i xTimeIncrement})}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelete\:task.h}
{\xe \v task.h\:vTaskDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelete ({\b xTaskHandle} {\i pxTaskToDelete})}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskEndScheduler\:task.h}
{\xe \v task.h\:vTaskEndScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskEndScheduler (void )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskGetRunTimeStats\:task.h}
{\xe \v task.h\:vTaskGetRunTimeStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskGetRunTimeStats (signed char * {\i pcWriteBuffer})}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskIncrementTick\:task.h}
{\xe \v task.h\:vTaskIncrementTick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskIncrementTick (void )}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskList\:task.h}
{\xe \v task.h\:vTaskList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskList (signed char * {\i pcWriteBuffer})}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskMissedYield\:task.h}
{\xe \v task.h\:vTaskMissedYield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskMissedYield (void )}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPlaceOnEventList\:task.h}
{\xe \v task.h\:vTaskPlaceOnEventList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPlaceOnEventList (const {\b xList} *const {\i pxEventList}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPlaceOnEventListRestricted\:task.h}
{\xe \v task.h\:vTaskPlaceOnEventListRestricted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPlaceOnEventListRestricted (const {\b xList} *const {\i pxEventList}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPriorityDisinherit\:task.h}
{\xe \v task.h\:vTaskPriorityDisinherit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPriorityDisinherit ({\b xTaskHandle} *const {\i pxMutexHolder})}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPriorityInherit\:task.h}
{\xe \v task.h\:vTaskPriorityInherit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPriorityInherit ({\b xTaskHandle} *const {\i pxMutexHolder})}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPrioritySet\:task.h}
{\xe \v task.h\:vTaskPrioritySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPrioritySet ({\b xTaskHandle} {\i pxTask}, unsigned {\b portBASE_TYPE} {\i uxNewPriority})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskResume\:task.h}
{\xe \v task.h\:vTaskResume}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskResume ({\b xTaskHandle} {\i pxTaskToResume})}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSetTaskNumber\:task.h}
{\xe \v task.h\:vTaskSetTaskNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSetTaskNumber ({\b xTaskHandle} {\i xTask}, unsigned {\b portBASE_TYPE} {\i uxHandle})}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSetTimeOutState\:task.h}
{\xe \v task.h\:vTaskSetTimeOutState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSetTimeOutState ({\b xTimeOutType} *const {\i pxTimeOut})}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskStartScheduler\:task.h}
{\xe \v task.h\:vTaskStartScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskStartScheduler (void )}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSuspend\:task.h}
{\xe \v task.h\:vTaskSuspend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSuspend ({\b xTaskHandle} {\i pxTaskToSuspend})}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSuspendAll\:task.h}
{\xe \v task.h\:vTaskSuspendAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSuspendAll (void )}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSwitchContext\:task.h}
{\xe \v task.h\:vTaskSwitchContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSwitchContext (void )}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskCallApplicationTaskHook\:task.h}
{\xe \v task.h\:xTaskCallApplicationTaskHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskCallApplicationTaskHook ({\b xTaskHandle} {\i xTask}, void * {\i pvParameter})}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b task.h} {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );\par}
Calls the hook function associated with xTask. Passing xTask as NULL has the effect of calling the Running tasks (the calling task) hook function.\par
pvParameter is passed to the hook function for the task to interpret as it wants. \par
}}
{\xe \v xTaskCheckForTimeOut\:task.h}
{\xe \v task.h\:xTaskCheckForTimeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskCheckForTimeOut ({\b xTimeOutType} *const {\i pxTimeOut}, {\b portTickType} *const {\i pxTicksToWait})}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGenericCreate\:task.h}
{\xe \v task.h\:xTaskGenericCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskGenericCreate ({\b pdTASK_CODE} {\i pxTaskCode}, const signed char *const {\i pcName}, unsigned short {\i usStackDepth}, void * {\i pvParameters}, unsigned {\b portBASE_TYPE} {\i uxPriority}, {\b xTaskHandle} * {\i pxCreatedTask}, {\b portSTACK_TYPE} * {\i puxStackBuffer}, const {\b xMemoryRegion} *const {\i xRegions})}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetCurrentTaskHandle\:task.h}
{\xe \v task.h\:xTaskGetCurrentTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xTaskHandle} xTaskGetCurrentTaskHandle (void )}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetIdleTaskHandle\:task.h}
{\xe \v task.h\:xTaskGetIdleTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xTaskHandle} xTaskGetIdleTaskHandle (void )}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b xTaskGetIdleTaskHandle()} is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in {\b FreeRTOSConfig.h}.\par
Simply returns the handle of the idle task. It is not valid to call {\b xTaskGetIdleTaskHandle()} before the scheduler has been started. \par
}}
{\xe \v xTaskGetSchedulerState\:task.h}
{\xe \v task.h\:xTaskGetSchedulerState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskGetSchedulerState (void )}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetTickCount\:task.h}
{\xe \v task.h\:xTaskGetTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xTaskGetTickCount (void )}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetTickCountFromISR\:task.h}
{\xe \v task.h\:xTaskGetTickCountFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xTaskGetTickCountFromISR (void )}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskIsTaskSuspended\:task.h}
{\xe \v task.h\:xTaskIsTaskSuspended}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskIsTaskSuspended ({\b xTaskHandle} {\i xTask})}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid signed portBASE_TYPE {\b xTaskIsTaskSuspended( xTaskHandle xTask )};\par}
Utility task that simply returns pdTRUE if the task referenced by xTask is currently in the Suspended state, or pdFALSE if the task referenced by xTask is in any other state. \par
}}
{\xe \v xTaskRemoveFromEventList\:task.h}
{\xe \v task.h\:xTaskRemoveFromEventList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskRemoveFromEventList (const {\b xList} *const {\i pxEventList})}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskResumeAll\:task.h}
{\xe \v task.h\:xTaskResumeAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskResumeAll (void )}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskResumeFromISR\:task.h}
{\xe \v task.h\:xTaskResumeFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskResumeFromISR ({\b xTaskHandle} {\i pxTaskToResume})}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/tasks.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/tasks.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/tasks.c}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
{\f2 #include "timers.h"}\par
{\f2 #include "StackMacros.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tskTaskControlBlock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MPU_WRAPPERS_INCLUDED_FROM_API_FILE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskIDLE_STACK_SIZE}\~ {\b configMINIMAL_STACK_SIZE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskSTACK_FILL_BYTE}\~ ( 0xa5U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskBLOCKED_CHAR}\~ ( ( signed char ) 'B' )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskREADY_CHAR}\~ ( ( signed char ) 'R' )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskDELETED_CHAR}\~ ( ( signed char ) 'D' )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tskSUSPENDED_CHAR}\~ ( ( signed char ) 'S' )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvAddTaskToReadyQueue}(pxTCB)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvCheckDelayedTasks}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prvGetTCBFromHandle}(pxHandle)\~ ( ( ( pxHandle ) == NULL ) ? ( {\b tskTCB} * ) {\b pxCurrentTCB} : ( {\b tskTCB} * ) ( pxHandle ) )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b tskTaskControlBlock} {\b tskTCB}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vApplicationStackOverflowHook} ({\b xTaskHandle} pxTask, signed char *pcTaskName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vApplicationTickHook} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelete} ({\b xTaskHandle} pxTaskToDelete)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelayUntil} ({\b portTickType} *const pxPreviousWakeTime, {\b portTickType} xTimeIncrement)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskDelay} ({\b portTickType} xTicksToDelay)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPrioritySet} ({\b xTaskHandle} pxTask, unsigned {\b portBASE_TYPE} uxNewPriority)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSuspend} ({\b xTaskHandle} pxTaskToSuspend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskIsTaskSuspended} ({\b xTaskHandle} xTask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskResume} ({\b xTaskHandle} pxTaskToResume)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskResumeFromISR} ({\b xTaskHandle} pxTaskToResume)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskStartScheduler} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskEndScheduler} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSuspendAll} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskResumeAll} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xTaskGetTickCount} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portTickType} {\b xTaskGetTickCountFromISR} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b portBASE_TYPE} {\b uxTaskGetNumberOfTasks} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskIncrementTick} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSwitchContext} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskPlaceOnEventList} (const {\b xList} *const pxEventList, {\b portTickType} xTicksToWait)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
signed {\b portBASE_TYPE} {\b xTaskRemoveFromEventList} (const {\b xList} *const pxEventList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskSetTimeOutState} ({\b xTimeOutType} *const pxTimeOut)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTaskCheckForTimeOut} ({\b xTimeOutType} *const pxTimeOut, {\b portTickType} *const pxTicksToWait)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vTaskMissedYield} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PRIVILEGED_DATA} {\b tskTCB} *volatile {\b pxCurrentTCB} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MPU_WRAPPERS_INCLUDED_FROM_API_FILE\:tasks.c}
{\xe \v tasks.c\:MPU_WRAPPERS_INCLUDED_FROM_API_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prvAddTaskToReadyQueue\:tasks.c}
{\xe \v tasks.c\:prvAddTaskToReadyQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvAddTaskToReadyQueue( pxTCB)}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid traceMOVED_TASK_TO_READY_STATE( pxTCB )                                                                             \\\par
    if( ( pxTCB )->uxPriority > uxTopReadyPriority )                                                                    \\\par
    \{                                                                                                                   \\\par
        uxTopReadyPriority = ( pxTCB )->uxPriority;                                                                     \\\par
    \}                                                                                                                   \\\par
    vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )\par
}
}
{\xe \v prvCheckDelayedTasks\:tasks.c}
{\xe \v tasks.c\:prvCheckDelayedTasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvCheckDelayedTasks()}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prvGetTCBFromHandle\:tasks.c}
{\xe \v tasks.c\:prvGetTCBFromHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prvGetTCBFromHandle( pxHandle)\~ ( ( ( pxHandle ) == NULL ) ? ( {\b tskTCB} * ) {\b pxCurrentTCB} : ( {\b tskTCB} * ) ( pxHandle ) )}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskBLOCKED_CHAR\:tasks.c}
{\xe \v tasks.c\:tskBLOCKED_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskBLOCKED_CHAR\~ ( ( signed char ) 'B' )}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskDELETED_CHAR\:tasks.c}
{\xe \v tasks.c\:tskDELETED_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskDELETED_CHAR\~ ( ( signed char ) 'D' )}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskIDLE_STACK_SIZE\:tasks.c}
{\xe \v tasks.c\:tskIDLE_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskIDLE_STACK_SIZE\~ {\b configMINIMAL_STACK_SIZE}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskREADY_CHAR\:tasks.c}
{\xe \v tasks.c\:tskREADY_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskREADY_CHAR\~ ( ( signed char ) 'R' )}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskSTACK_FILL_BYTE\:tasks.c}
{\xe \v tasks.c\:tskSTACK_FILL_BYTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskSTACK_FILL_BYTE\~ ( 0xa5U )}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tskSUSPENDED_CHAR\:tasks.c}
{\xe \v tasks.c\:tskSUSPENDED_CHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tskSUSPENDED_CHAR\~ ( ( signed char ) 'S' )}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v tskTCB\:tasks.c}
{\xe \v tasks.c\:tskTCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b tskTaskControlBlock}  {\b tskTCB}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v uxTaskGetNumberOfTasks\:tasks.c}
{\xe \v tasks.c\:uxTaskGetNumberOfTasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned {\b portBASE_TYPE} uxTaskGetNumberOfTasks (void )}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vApplicationStackOverflowHook\:tasks.c}
{\xe \v tasks.c\:vApplicationStackOverflowHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vApplicationStackOverflowHook ({\b xTaskHandle} {\i pxTask}, signed char * {\i pcTaskName})}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vApplicationTickHook\:tasks.c}
{\xe \v tasks.c\:vApplicationTickHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vApplicationTickHook (void )}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelay\:tasks.c}
{\xe \v tasks.c\:vTaskDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelay ({\b portTickType} {\i xTicksToDelay})}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelayUntil\:tasks.c}
{\xe \v tasks.c\:vTaskDelayUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelayUntil ({\b portTickType} *const {\i pxPreviousWakeTime}, {\b portTickType} {\i xTimeIncrement})}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskDelete\:tasks.c}
{\xe \v tasks.c\:vTaskDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskDelete ({\b xTaskHandle} {\i pxTaskToDelete})}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskEndScheduler\:tasks.c}
{\xe \v tasks.c\:vTaskEndScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskEndScheduler (void )}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskIncrementTick\:tasks.c}
{\xe \v tasks.c\:vTaskIncrementTick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskIncrementTick (void )}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskMissedYield\:tasks.c}
{\xe \v tasks.c\:vTaskMissedYield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskMissedYield (void )}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPlaceOnEventList\:tasks.c}
{\xe \v tasks.c\:vTaskPlaceOnEventList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPlaceOnEventList (const {\b xList} *const {\i pxEventList}, {\b portTickType} {\i xTicksToWait})}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskPrioritySet\:tasks.c}
{\xe \v tasks.c\:vTaskPrioritySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskPrioritySet ({\b xTaskHandle} {\i pxTask}, unsigned {\b portBASE_TYPE} {\i uxNewPriority})}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskResume\:tasks.c}
{\xe \v tasks.c\:vTaskResume}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskResume ({\b xTaskHandle} {\i pxTaskToResume})}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSetTimeOutState\:tasks.c}
{\xe \v tasks.c\:vTaskSetTimeOutState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSetTimeOutState ({\b xTimeOutType} *const {\i pxTimeOut})}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskStartScheduler\:tasks.c}
{\xe \v tasks.c\:vTaskStartScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskStartScheduler (void )}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSuspend\:tasks.c}
{\xe \v tasks.c\:vTaskSuspend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSuspend ({\b xTaskHandle} {\i pxTaskToSuspend})}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSuspendAll\:tasks.c}
{\xe \v tasks.c\:vTaskSuspendAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSuspendAll (void )}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vTaskSwitchContext\:tasks.c}
{\xe \v tasks.c\:vTaskSwitchContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vTaskSwitchContext (void )}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskCheckForTimeOut\:tasks.c}
{\xe \v tasks.c\:xTaskCheckForTimeOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskCheckForTimeOut ({\b xTimeOutType} *const {\i pxTimeOut}, {\b portTickType} *const {\i pxTicksToWait})}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetTickCount\:tasks.c}
{\xe \v tasks.c\:xTaskGetTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xTaskGetTickCount (void )}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskGetTickCountFromISR\:tasks.c}
{\xe \v tasks.c\:xTaskGetTickCountFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portTickType} xTaskGetTickCountFromISR (void )}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskIsTaskSuspended\:tasks.c}
{\xe \v tasks.c\:xTaskIsTaskSuspended}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskIsTaskSuspended ({\b xTaskHandle} {\i xTask})}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
task. h {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid signed portBASE_TYPE {\b xTaskIsTaskSuspended( xTaskHandle xTask )};\par}
Utility task that simply returns pdTRUE if the task referenced by xTask is currently in the Suspended state, or pdFALSE if the task referenced by xTask is in any other state. \par
}}
{\xe \v xTaskRemoveFromEventList\:tasks.c}
{\xe \v tasks.c\:xTaskRemoveFromEventList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskRemoveFromEventList (const {\b xList} *const {\i pxEventList})}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskResumeAll\:tasks.c}
{\xe \v tasks.c\:xTaskResumeAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
signed {\b portBASE_TYPE} xTaskResumeAll (void )}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTaskResumeFromISR\:tasks.c}
{\xe \v tasks.c\:xTaskResumeFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTaskResumeFromISR ({\b xTaskHandle} {\i pxTaskToResume})}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v pxCurrentTCB\:tasks.c}
{\xe \v tasks.c\:pxCurrentTCB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PRIVILEGED_DATA} {\b tskTCB}* volatile pxCurrentTCB = NULL}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.c File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.c}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.c}
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FreeRTOS.h"}\par
{\f2 #include "task.h"}\par
{\f2 #include "queue.h"}\par
{\f2 #include "timers.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MPU_WRAPPERS_INCLUDED_FROM_API_FILE}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MPU_WRAPPERS_INCLUDED_FROM_API_FILE\:timers.c}
{\xe \v timers.c\:MPU_WRAPPERS_INCLUDED_FROM_API_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.h File Reference\par \pard\plain 
{\tc\tcl2 \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.h}
{\xe \v Desktop/Git Rep/Lab1_483/Lab483_1_StateMach/Lab483_1_StateMach/src/timers.h}
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "portable.h"}\par
{\f2 #include "list.h"}\par
{\f2 #include "task.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tmrCOMMAND_START}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tmrCOMMAND_STOP}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tmrCOMMAND_CHANGE_PERIOD}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b tmrCOMMAND_DELETE}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerStart}(xTimer, xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCount}() ), NULL, ( xBlockTime ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerStop}(xTimer, xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_STOP}, 0U, NULL, ( xBlockTime ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerChangePeriod}(xTimer, xNewPeriod, xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_CHANGE_PERIOD}, ( xNewPeriod ), NULL, ( xBlockTime ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerDelete}(xTimer, xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_DELETE}, 0U, NULL, ( xBlockTime ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerReset}(xTimer, xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCount}() ), NULL, ( xBlockTime ) )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerStartFromISR}(xTimer, pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCountFromISR}() ), ( pxHigherPriorityTaskWoken ), 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerStopFromISR}(xTimer, pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_STOP}, 0, ( pxHigherPriorityTaskWoken ), 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerChangePeriodFromISR}(xTimer, xNewPeriod, pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_CHANGE_PERIOD}, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b xTimerResetFromISR}(xTimer, pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCountFromISR}() ), ( pxHigherPriorityTaskWoken ), 0U )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b xTimerHandle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b tmrTIMER_CALLBACK} )({\b xTimerHandle} xTimer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xTimerHandle} {\b xTimerCreate} (const signed char *pcTimerName, {\b portTickType} xTimerPeriodInTicks, unsigned {\b portBASE_TYPE} uxAutoReload, void *pvTimerID, {\b tmrTIMER_CALLBACK} pxCallbackFunction) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pvTimerGetTimerID} ({\b xTimerHandle} xTimer) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTimerIsTimerActive} ({\b xTimerHandle} xTimer) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b xTaskHandle} {\b xTimerGetTimerDaemonTaskHandle} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTimerCreateTimerTask} (void) {\b PRIVILEGED_FUNCTION}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b portBASE_TYPE} {\b xTimerGenericCommand} ({\b xTimerHandle} xTimer, {\b portBASE_TYPE} xCommandID, {\b portTickType} xOptionalValue, signed {\b portBASE_TYPE} *pxHigherPriorityTaskWoken, {\b portTickType} xBlockTime) {\b PRIVILEGED_FUNCTION}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v tmrCOMMAND_CHANGE_PERIOD\:timers.h}
{\xe \v timers.h\:tmrCOMMAND_CHANGE_PERIOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tmrCOMMAND_CHANGE_PERIOD\~ 2}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tmrCOMMAND_DELETE\:timers.h}
{\xe \v timers.h\:tmrCOMMAND_DELETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tmrCOMMAND_DELETE\~ 3}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tmrCOMMAND_START\:timers.h}
{\xe \v timers.h\:tmrCOMMAND_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tmrCOMMAND_START\~ 0}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tmrCOMMAND_STOP\:timers.h}
{\xe \v timers.h\:tmrCOMMAND_STOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define tmrCOMMAND_STOP\~ 1}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimerChangePeriod\:timers.h}
{\xe \v timers.h\:xTimerChangePeriod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerChangePeriod( xTimer,  xNewPeriod,  xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_CHANGE_PERIOD}, ( xNewPeriod ), NULL, ( xBlockTime ) )}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE xTimerChangePeriod( xTimerHandle xTimer, portTickType xNewPeriod, portTickType xBlockTime );\par
Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task though a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\par
{\b xTimerChangePeriod()} changes the period of a timer that was previously created using the {\b xTimerCreate()} API function.\par
{\b xTimerChangePeriod()} can be called to change the period of an active or dormant state timer.\par
The configUSE_TIMERS configuration constant must be set to 1 for {\b xTimerChangePeriod()} to be available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer that is having its period changed.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xNewPeriod} \cell }{The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_RATE_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_RATE_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xBlockTime} \cell }{Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when {\b xTimerChangePeriod()} was called. xBlockTime is ignored if {\b xTimerChangePeriod()} is called before the scheduler is started.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// This function assumes xTimer has already been created. If the timer // referenced by xTimer is already active when it is called, then the timer // is deleted. If the timer referenced by xTimer is not active when it is // called, then the period of the timer is set to 500ms and the timer is // started. void vAFunction( xTimerHandle xTimer ) \{ if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )" \{ // xTimer is already active - delete it. {\b xTimerDelete( xTimer )}; \} else \{ // xTimer is not active, change its period to 500ms. This will also // cause the timer to start. Block for a maximum of 100 ticks if the // change period command cannot immediately be sent to the timer // command queue. if( xTimerChangePeriod( xTimer, 500 / portTICK_RATE_MS, 100 ) == pdPASS ) \{ // The command was successfully sent. \} else \{ // The command could not be sent, even after waiting for 100 ticks // to pass. Take appropriate action here. \} \} \} \par
}}
{\xe \v xTimerChangePeriodFromISR\:timers.h}
{\xe \v timers.h\:xTimerChangePeriodFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerChangePeriodFromISR( xTimer,  xNewPeriod,  pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_CHANGE_PERIOD}, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE xTimerChangePeriodFromISR( xTimerHandle xTimer, portTickType xNewPeriod, portBASE_TYPE *pxHigherPriorityTaskWoken );\par
A version of {\b xTimerChangePeriod()} that can be called from an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer that is having its period changed.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xNewPeriod} \cell }{The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_RATE_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_RATE_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling {\b xTimerChangePeriodFromISR()} writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling {\b xTimerChangePeriodFromISR()} causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the {\b xTimerChangePeriodFromISR()} function. If {\b xTimerChangePeriodFromISR()} sets this value to pdTRUE then a context switch should be performed before the interrupt exits.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// This scenario assumes xTimer has already been created and started. When // an interrupt occurs, the period of xTimer should be changed to 500ms.\par
// The interrupt service routine that changes the period of xTimer. void vAnExampleInterruptServiceRoutine( void ) \{ portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // The interrupt has occurred - change the period of xTimer to 500ms.\par
// xHigherPriorityTaskWoken was set to pdFALSE where it was defined\par
// (within this function).  As this is an interrupt service routine, only\par
// FreeRTOS API functions that end in "FromISR" can be used.\par
if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )\par
\{\par
    // The command to change the timers period was not executed\par
    // successfully.  Take appropriate action here.\par
\}\par
\par
// If xHigherPriorityTaskWoken equals pdTRUE, then a context switch\par
// should be performed.  The syntax required to perform a context switch\par
// from inside an ISR varies from port to port, and from compiler to\par
// compiler.  Inspect the demos for the port you are using to find the\par
// actual syntax required.\par
if( xHigherPriorityTaskWoken != pdFALSE )\par
\{\par
    // Call the interrupt safe yield function here (actual function\par
    // depends on the FreeRTOS port being used.\par
\}\par
}
 \par
}}
{\xe \v xTimerDelete\:timers.h}
{\xe \v timers.h\:xTimerDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerDelete( xTimer,  xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_DELETE}, 0U, NULL, ( xBlockTime ) )}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE {\b xTimerDelete( xTimerHandle xTimer, portTickType xBlockTime )};\par
Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task though a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\par
{\b xTimerDelete()} deletes a timer that was previously created using the {\b xTimerCreate()} API function.\par
The configUSE_TIMERS configuration constant must be set to 1 for {\b xTimerDelete()} to be available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being deleted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xBlockTime} \cell }{Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when {\b xTimerDelete()} was called. xBlockTime is ignored if {\b xTimerDelete()} is called before the scheduler is started.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
See the {\b xTimerChangePeriod()} API function example usage scenario. \par
}}
{\xe \v xTimerReset\:timers.h}
{\xe \v timers.h\:xTimerReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerReset( xTimer,  xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCount}() ), NULL, ( xBlockTime ) )}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE {\b xTimerReset( xTimerHandle xTimer, portTickType xBlockTime )};\par
Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task though a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\par
{\b xTimerReset()} re-starts a timer that was previously created using the {\b xTimerCreate()} API function. If the timer had already been started and was already in the active state, then {\b xTimerReset()} will cause the timer to re-evaluate its expiry time so that it is relative to when {\b xTimerReset()} was called. If the timer was in the dormant state then {\b xTimerReset()} has equivalent functionality to the {\b xTimerStart()} API function.\par
Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after {\b xTimerReset()} was called, where 'n' is the timers defined period.\par
It is valid to call {\b xTimerReset()} before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when {\b xTimerReset()} was called.\par
The configUSE_TIMERS configuration constant must be set to 1 for {\b xTimerReset()} to be available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being reset/started/restarted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xBlockTime} \cell }{Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when {\b xTimerReset()} was called. xBlockTime is ignored if {\b xTimerReset()} is called before the scheduler is started.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when {\b xTimerStart()} is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// When a key is pressed, an LCD back-light is switched on. If 5 seconds pass // without a key being pressed, then the LCD back-light is switched off. In // this case, the timer is a one-shot timer.\par
xTimerHandle xBacklightTimer = NULL;\par
// The callback function assigned to the one-shot timer. In this case the // parameter is not used. void vBacklightTimerCallback( xTimerHandle pxTimer ) \{ // The timer expired, therefore 5 seconds must have passed since a key // was pressed. Switch off the LCD back-light. vSetBacklightState( BACKLIGHT_OFF ); \}\par
// The key press event handler. void vKeyPressEventHandler( char cKey ) \{ // Ensure the LCD back-light is on, then reset the timer that is // responsible for turning the back-light off after 5 seconds of // key inactivity. Wait 10 ticks for the command to be successfully sent // if it cannot be sent immediately. vSetBacklightState( BACKLIGHT_ON ); if( {\b xTimerReset( xBacklightTimer, 100 )} != pdPASS ) \{ // The reset command was not executed successfully. Take appropriate // action here. \}\par
// Perform the rest of the key processing here. \}\par
void {\b main( void )} \{ long x; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // Create then start the one-shot timer that is responsible for turning\par
// the back-light off if no keys are pressed within a 5 second period.\par
xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.\par
                                ( 5000 / portTICK_RATE_MS), // The timer period in ticks.\par
                                pdFALSE,                    // The timer is a one-shot timer.\par
                                0,                          // The id is not used by the callback so can take any value.\par
                                vBacklightTimerCallback     // The callback function that switches the LCD back-light off.\par
                              );\par
\par
if( xBacklightTimer == NULL )\par
\{\par
    // The timer was not created.\par
\}\par
else\par
\{\par
    // Start the timer.  No block time is specified, and even if one was\par
    // it would be ignored because the scheduler has not yet been\par
    // started.\par
    if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )\par
    \{\par
        // The timer could not be set into the Active state.\par
    \}\par
\}\par
\par
// ...\par
// Create tasks here.\par
// ...\par
\par
// Starting the scheduler will start the timer running as it has already\par
// been set into the active state.\par
xTaskStartScheduler();\par
\par
// Should not reach here.\par
for( ;; );\par
}
 \par
}}
{\xe \v xTimerResetFromISR\:timers.h}
{\xe \v timers.h\:xTimerResetFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerResetFromISR( xTimer,  pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCountFromISR}() ), ( pxHigherPriorityTaskWoken ), 0U )}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE xTimerResetFromISR( xTimerHandle xTimer, portBASE_TYPE *pxHigherPriorityTaskWoken );\par
A version of {\b xTimerReset()} that can be called from an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer that is to be started, reset, or restarted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling {\b xTimerResetFromISR()} writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling {\b xTimerResetFromISR()} causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the {\b xTimerResetFromISR()} function. If {\b xTimerResetFromISR()} sets this value to pdTRUE then a context switch should be performed before the interrupt exits.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when {\b xTimerResetFromISR()} is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// This scenario assumes xBacklightTimer has already been created. When a // key is pressed, an LCD back-light is switched on. If 5 seconds pass // without a key being pressed, then the LCD back-light is switched off. In // this case, the timer is a one-shot timer, and unlike the example given for // the {\b xTimerReset()} function, the key press event handler is an interrupt // service routine.\par
// The callback function assigned to the one-shot timer. In this case the // parameter is not used. void vBacklightTimerCallback( xTimerHandle pxTimer ) \{ // The timer expired, therefore 5 seconds must have passed since a key // was pressed. Switch off the LCD back-light. vSetBacklightState( BACKLIGHT_OFF ); \}\par
// The key press interrupt service routine. void vKeyPressEventInterruptHandler( void ) \{ portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // Ensure the LCD back-light is on, then reset the timer that is\par
// responsible for turning the back-light off after 5 seconds of\par
// key inactivity.  This is an interrupt service routine so can only\par
// call FreeRTOS API functions that end in "FromISR".\par
vSetBacklightState( BACKLIGHT_ON );\par
\par
// xTimerStartFromISR() or xTimerResetFromISR() could be called here\par
// as both cause the timer to re-calculate its expiry time.\par
// xHigherPriorityTaskWoken was initialised to pdFALSE when it was\par
// declared (in this function).\par
if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )\par
\{\par
    // The reset command was not executed successfully.  Take appropriate\par
    // action here.\par
\}\par
\par
// Perform the rest of the key processing here.\par
\par
// If xHigherPriorityTaskWoken equals pdTRUE, then a context switch\par
// should be performed.  The syntax required to perform a context switch\par
// from inside an ISR varies from port to port, and from compiler to\par
// compiler.  Inspect the demos for the port you are using to find the\par
// actual syntax required.\par
if( xHigherPriorityTaskWoken != pdFALSE )\par
\{\par
    // Call the interrupt safe yield function here (actual function\par
    // depends on the FreeRTOS port being used.\par
\}\par
}
 \par
}}
{\xe \v xTimerStart\:timers.h}
{\xe \v timers.h\:xTimerStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerStart( xTimer,  xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCount}() ), NULL, ( xBlockTime ) )}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE {\b xTimerStart( xTimerHandle xTimer, portTickType xBlockTime )};\par
Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task though a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\par
{\b xTimerStart()} starts a timer that was previously created using the {\b xTimerCreate()} API function. If the timer had already been started and was already in the active state, then {\b xTimerStart()} has equivalent functionality to the {\b xTimerReset()} API function.\par
Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after {\b xTimerStart()} was called, where 'n' is the timers defined period.\par
It is valid to call {\b xTimerStart()} before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when {\b xTimerStart()} was called.\par
The configUSE_TIMERS configuration constant must be set to 1 for {\b xTimerStart()} to be available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being started/restarted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xBlockTime} \cell }{Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when {\b xTimerStart()} was called. xBlockTime is ignored if {\b xTimerStart()} is called before the scheduler is started.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the start command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when {\b xTimerStart()} is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
See the {\b xTimerCreate()} API function example usage scenario. \par
}}
{\xe \v xTimerStartFromISR\:timers.h}
{\xe \v timers.h\:xTimerStartFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerStartFromISR( xTimer,  pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_START}, ( {\b xTaskGetTickCountFromISR}() ), ( pxHigherPriorityTaskWoken ), 0U )}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE xTimerStartFromISR( xTimerHandle xTimer, portBASE_TYPE *pxHigherPriorityTaskWoken );\par
A version of {\b xTimerStart()} that can be called from an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being started/restarted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling {\b xTimerStartFromISR()} writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling {\b xTimerStartFromISR()} causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the {\b xTimerStartFromISR()} function. If {\b xTimerStartFromISR()} sets this value to pdTRUE then a context switch should be performed before the interrupt exits.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when {\b xTimerStartFromISR()} is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// This scenario assumes xBacklightTimer has already been created. When a // key is pressed, an LCD back-light is switched on. If 5 seconds pass // without a key being pressed, then the LCD back-light is switched off. In // this case, the timer is a one-shot timer, and unlike the example given for // the {\b xTimerReset()} function, the key press event handler is an interrupt // service routine.\par
// The callback function assigned to the one-shot timer. In this case the // parameter is not used. void vBacklightTimerCallback( xTimerHandle pxTimer ) \{ // The timer expired, therefore 5 seconds must have passed since a key // was pressed. Switch off the LCD back-light. vSetBacklightState( BACKLIGHT_OFF ); \}\par
// The key press interrupt service routine. void vKeyPressEventInterruptHandler( void ) \{ portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // Ensure the LCD back-light is on, then restart the timer that is\par
// responsible for turning the back-light off after 5 seconds of\par
// key inactivity.  This is an interrupt service routine so can only\par
// call FreeRTOS API functions that end in "FromISR".\par
vSetBacklightState( BACKLIGHT_ON );\par
\par
// xTimerStartFromISR() or xTimerResetFromISR() could be called here\par
// as both cause the timer to re-calculate its expiry time.\par
// xHigherPriorityTaskWoken was initialised to pdFALSE when it was\par
// declared (in this function).\par
if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )\par
\{\par
    // The start command was not executed successfully.  Take appropriate\par
    // action here.\par
\}\par
\par
// Perform the rest of the key processing here.\par
\par
// If xHigherPriorityTaskWoken equals pdTRUE, then a context switch\par
// should be performed.  The syntax required to perform a context switch\par
// from inside an ISR varies from port to port, and from compiler to\par
// compiler.  Inspect the demos for the port you are using to find the\par
// actual syntax required.\par
if( xHigherPriorityTaskWoken != pdFALSE )\par
\{\par
    // Call the interrupt safe yield function here (actual function\par
    // depends on the FreeRTOS port being used.\par
\}\par
}
 \par
}}
{\xe \v xTimerStop\:timers.h}
{\xe \v timers.h\:xTimerStop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerStop( xTimer,  xBlockTime)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_STOP}, 0U, NULL, ( xBlockTime ) )}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE {\b xTimerStop( xTimerHandle xTimer, portTickType xBlockTime )};\par
Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task though a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\par
{\b xTimerStop()} stops a timer that was previously started using either of the The {\b xTimerStart()}, {\b xTimerReset()}, {\b xTimerStartFromISR()}, {\b xTimerResetFromISR()}, {\b xTimerChangePeriod()} or {\b xTimerChangePeriodFromISR()} API functions.\par
Stopping a timer ensures the timer is not in the active state.\par
The configUSE_TIMERS configuration constant must be set to 1 for {\b xTimerStop()} to be available.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being stopped.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xBlockTime} \cell }{Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when {\b xTimerStop()} was called. xBlockTime is ignored if {\b xTimerStop()} is called before the scheduler is started.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
See the {\b xTimerCreate()} API function example usage scenario. \par
}}
{\xe \v xTimerStopFromISR\:timers.h}
{\xe \v timers.h\:xTimerStopFromISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define xTimerStopFromISR( xTimer,  pxHigherPriorityTaskWoken)\~ {\b xTimerGenericCommand}( ( xTimer ), {\b tmrCOMMAND_STOP}, 0, ( pxHigherPriorityTaskWoken ), 0U )}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE xTimerStopFromISR( xTimerHandle xTimer, portBASE_TYPE *pxHigherPriorityTaskWoken );\par
A version of {\b xTimerStop()} that can be called from an interrupt service routine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The handle of the timer being stopped.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxHigherPriorityTaskWoken} \cell }{The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling {\b xTimerStopFromISR()} writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling {\b xTimerStopFromISR()} causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the {\b xTimerStopFromISR()} function. If {\b xTimerStopFromISR()} sets this value to pdTRUE then a context switch should be performed before the interrupt exits.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.\par
}Example usage:\par
// This scenario assumes xTimer has already been created and started. When // an interrupt occurs, the timer should be simply stopped.\par
// The interrupt service routine that stops the timer. void vAnExampleInterruptServiceRoutine( void ) \{ portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // The interrupt has occurred - simply stop the timer.\par
// xHigherPriorityTaskWoken was set to pdFALSE where it was defined\par
// (within this function).  As this is an interrupt service routine, only\par
// FreeRTOS API functions that end in "FromISR" can be used.\par
if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )\par
\{\par
    // The stop command was not executed successfully.  Take appropriate\par
    // action here.\par
\}\par
\par
// If xHigherPriorityTaskWoken equals pdTRUE, then a context switch\par
// should be performed.  The syntax required to perform a context switch\par
// from inside an ISR varies from port to port, and from compiler to\par
// compiler.  Inspect the demos for the port you are using to find the\par
// actual syntax required.\par
if( xHigherPriorityTaskWoken != pdFALSE )\par
\{\par
    // Call the interrupt safe yield function here (actual function\par
    // depends on the FreeRTOS port being used.\par
\}\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v tmrTIMER_CALLBACK\:timers.h}
{\xe \v timers.h\:tmrTIMER_CALLBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* tmrTIMER_CALLBACK)({\b xTimerHandle} xTimer)}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimerHandle\:timers.h}
{\xe \v timers.h\:xTimerHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b xTimerHandle}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type by which software timers are referenced. For example, a call to {\b xTimerCreate()} returns an xTimerHandle variable that can then be used to reference the subject timer in calls to other software timer API functions (for example, {\b xTimerStart()}, {\b xTimerReset()}, etc.). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pvTimerGetTimerID\:timers.h}
{\xe \v timers.h\:pvTimerGetTimerID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pvTimerGetTimerID ({\b xTimerHandle} {\i xTimer})}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
void *pvTimerGetTimerID( xTimerHandle xTimer );\par
Returns the ID assigned to the timer.\par
IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.\par
If the same callback function is assigned to multiple timers then the timer ID can be used within the callback function to identify which timer actually expired.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The timer being queried.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The ID assigned to the timer being queried.\par
}Example usage:\par
See the {\b xTimerCreate()} API function example usage scenario. \par
}}
{\xe \v xTimerCreate\:timers.h}
{\xe \v timers.h\:xTimerCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xTimerHandle} xTimerCreate (const signed char * {\i pcTimerName}, {\b portTickType} {\i xTimerPeriodInTicks}, unsigned {\b portBASE_TYPE} {\i uxAutoReload}, void * {\i pvTimerID}, {\b tmrTIMER_CALLBACK} {\i pxCallbackFunction})}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void * pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction );\par
Creates a new software timer instance. This allocates the storage required by the new timer, initialises the new timers internal state, and returns a handle by which the new timer can be referenced.\par
Timers are created in the dormant state. The {\b xTimerStart()}, {\b xTimerReset()}, {\b xTimerStartFromISR()}, {\b xTimerResetFromISR()}, {\b xTimerChangePeriod()} and {\b xTimerChangePeriodFromISR()} API functions can all be used to transition a timer into the active state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pcTimerName} \cell }{A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimerPeriodInTicks} \cell }{The timer period. The time is defined in tick periods so the constant portTICK_RATE_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_RATE_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uxAutoReload} \cell }{If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pvTimerID} \cell }{An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pxCallbackFunction} \cell }{The function to call when the timer expires. Callback functions must have the prototype defined by tmrTIMER_CALLBACK, which is "void vCallbackFunction( xTimerHandle xTimer );".\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If the timer is successfully create then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then 0 is returned.\par
}Example usage:\par
#define NUM_TIMERS 5\par
// An array to hold handles to the created timers. xTimerHandle xTimers[ NUM_TIMERS ];\par
// An array to hold a count of the number of times each timer expires. long lExpireCounters[ NUM_TIMERS ] = \{ 0 \};\par
// Define a callback function that will be used by multiple timer instances. // The callback function does nothing but count the number of times the // associated timer expires, and stop the timer once the timer has expired // 10 times. void vTimerCallback( xTimerHandle pxTimer ) \{ long lArrayIndex; const long xMaxExpiryCountBeforeStopping = 10; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    // Optionally do something if the pxTimer parameter is NULL.\par
   configASSERT( pxTimer );\par
\par
// Which timer expired?\par
lArrayIndex = ( long ) pvTimerGetTimerID( pxTimer );\par
\par
// Increment the number of times that pxTimer has expired.\par
lExpireCounters[ lArrayIndex ] += 1;\par
\par
// If the timer has expired 10 times then stop it from running.\par
if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )\par
\{\par
    // Do not use a block time if calling a timer API function from a\par
    // timer callback function, as doing so could cause a deadlock!\par
    xTimerStop( pxTimer, 0 );\par
\}\par
}
 \}\par
void {\b main( void )} \{ long x; {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // Create then start some timers.  Starting the timers before the scheduler\par
// has been started means the timers will start running immediately that\par
// the scheduler starts.\par
for( x = 0; x < NUM_TIMERS; x++ )\par
\{\par
    xTimers[ x ] = xTimerCreate(     "Timer",         // Just a text name, not used by the kernel.\par
                                    ( 100 * x ),     // The timer period in ticks.\par
                                    pdTRUE,         // The timers will auto-reload themselves when they expire.\par
                                    ( void * ) x,     // Assign each timer a unique id equal to its array index.\par
                                    vTimerCallback     // Each timer calls the same callback when it expires.\par
                                );\par
\par
    if( xTimers[ x ] == NULL )\par
    \{\par
        // The timer was not created.\par
    \}\par
    else\par
    \{\par
        // Start the timer.  No block time is specified, and even if one was\par
        // it would be ignored because the scheduler has not yet been\par
        // started.\par
        if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )\par
        \{\par
            // The timer could not be set into the Active state.\par
        \}\par
    \}\par
\}\par
\par
// ...\par
// Create tasks here.\par
// ...\par
\par
// Starting the scheduler will start the timers running as they have already\par
// been set into the active state.\par
xTaskStartScheduler();\par
\par
// Should not reach here.\par
for( ;; );\par
}
 \par
}}
{\xe \v xTimerCreateTimerTask\:timers.h}
{\xe \v timers.h\:xTimerCreateTimerTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTimerCreateTimerTask (void )}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimerGenericCommand\:timers.h}
{\xe \v timers.h\:xTimerGenericCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTimerGenericCommand ({\b xTimerHandle} {\i xTimer}, {\b portBASE_TYPE} {\i xCommandID}, {\b portTickType} {\i xOptionalValue}, signed {\b portBASE_TYPE} * {\i pxHigherPriorityTaskWoken}, {\b portTickType} {\i xBlockTime})}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xTimerGetTimerDaemonTaskHandle\:timers.h}
{\xe \v timers.h\:xTimerGetTimerDaemonTaskHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b xTaskHandle} xTimerGetTimerDaemonTaskHandle (void )}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b xTimerGetTimerDaemonTaskHandle()} is only available if INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in {\b FreeRTOSConfig.h}.\par
Simply returns the handle of the timer service/daemon task. It it not valid to call {\b xTimerGetTimerDaemonTaskHandle()} before the scheduler has been started. \par
}}
{\xe \v xTimerIsTimerActive\:timers.h}
{\xe \v timers.h\:xTimerIsTimerActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b portBASE_TYPE} xTimerIsTimerActive ({\b xTimerHandle} {\i xTimer})}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
portBASE_TYPE {\b xTimerIsTimerActive( xTimerHandle xTimer )};\par
Queries a timer to see if it is active or dormant.\par
A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired on-shot timer that has not been restarted.\par
Timers are created in the dormant state. The {\b xTimerStart()}, {\b xTimerReset()}, {\b xTimerStartFromISR()}, {\b xTimerResetFromISR()}, {\b xTimerChangePeriod()} and {\b xTimerChangePeriodFromISR()} API functions can all be used to transition a timer into the active state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i xTimer} \cell }{The timer being queried.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.\par
}Example usage:\par
// This function assumes xTimer has already been created. void vAFunction( xTimerHandle xTimer ) \{ if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )" \{ // xTimer is active, do something. \} else \{ // xTimer is not active, do something else. \} \} \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}